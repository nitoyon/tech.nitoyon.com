<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Wed, 27 Oct 2021 11:41:13 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />


		<item>
			<title>はじめてゲームプログラミング作品 BREAK THE WAY を作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2021/10/28/break-the-way/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2021/10/28/break-the-way/</guid>
			<pubDate>Thu, 28 Oct 2021 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>話題からは少し乗り遅れてしまった感はありますが、Switch 用ソフトの <a href="https://amzn.to/3mf47cM">ナビつき! つくってわかる はじめてゲームプログラミング</a> で遊んでみたついでに、1つゲームを作ってみました。</p>

<p><blockquote class="twitter-tweet"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%82%B2%E3%83%BC%E3%83%A0%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0?src=hash&amp;ref_src=twsrc%5Etfw">#はじめてゲームプログラミング</a> で上スクロールのアスレチックゲームを作ってみた。後半は来た道の破壊ゲームになるよ。<br>G 005 9TG 3PF<a href="https://twitter.com/hashtag/GameBuilderGarage?src=hash&amp;ref_src=twsrc%5Etfw">#GameBuilderGarage</a> <a href="https://twitter.com/hashtag/%E3%81%AF%E3%81%98%E3%83%97%E3%83%AD?src=hash&amp;ref_src=twsrc%5Etfw">#はじプロ</a> <a href="https://t.co/EGDBWP6zZf">pic.twitter.com/EGDBWP6zZf</a></p>&mdash; nitoyon (にとよん) (@nitoyon) <a href="https://twitter.com/nitoyon/status/1441797051986038786?ref_src=twsrc%5Etfw">September 25, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<ul>
<li>ゲーム ID: <em>G 005 9TG 3PF</em></li>
<li>タイトル: <em>BREAK THE WAY</em></li>
</ul>

<h1>ゲームについて</h1>

<p>この手のゲームに慣れていないうちの子どもにテストプレイしてもらいながら難易度を調整したので、だいぶ簡単だと思います。</p>

<p>1 つのゲームで 3 種類のミニゲームの要素を組み込んでみました。</p>

<p>ゲーム名の <em>BREAK THE WAY</em> は「道を切り開く」と「道をぶっこわす」のダブルミーニングになっています。</p>

<h1>実況してもらえた</h1>

<p>ツイートなどで少しだけ宣伝したら、YouTube で実況してくれた人がいたので埋め込んでおきます。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/tzQp02Upe0E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/lMR-aY1Q1x0?start=183" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/u6ZdK6AotKc?start=1899" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>反応を動画でもらえる時代。いい時代ですね。</p>

<h1>はじめてゲームプログラミング 雑感</h1>

<p>1 つゲームを完成させたので、はじめてゲームプログラミングについて感じたことを、だらだらと書いておきます。</p>

<h2>ナビつきレッスン</h2>

<p>「ナビつきレッスン」をやれば、一通りのゲームの作り方が分かるのはさすがだと思いました。</p>

<p>いろんな人が言ってることの繰り返しになりますが、「ナビつきレッスン」の中では「何か変更したら確かめる」という手順が徹底されています。
プログラムを変更したら即座に反映される楽しさや、ときには失敗を経験して修正しながら先に進めていく開発フローを体験できます。
開発のベストプラクティスを体感しながら、先に進めていけるのが素晴らしいですね。</p>

<p>レッスンで出てくるゲームをアレンジするだけでも、ちょっとしたゲームになりますね。</p>

<p>ただ、レッスンの中で説明もなく出てくる「れんけつ」の連結面を選ぶところなどは、XYZ 座標系の理解が必要だし、さらには回転してたりするとローカル座標系・ワールド座標系の理解も必要となるし、ある程度の数学的知識は必要だろうとは思います。まぁ、分からなくても、適当にパラメーターをいじりつつ、希望通りの挙動になるまでトライアンドエラーしてれば、そのうち分かるようになるかもしれないから、あえてぼかしてるのかなーという気はします。</p>

<p>あと、レーシングゲームの勝利判定のロジックはだいぶややこしかった...。</p>

<h2>ノードンガレージ</h2>

<p>ループとか条件分岐とか変数がないのに、それでも意外となんとかなるもんなんだなーと思った。
(変数については、カウンターノードンというのがあるにはあるが、増減とリセットしかできなくて代入できないので変数とはいいがたい...)</p>

<p>あとは、ドット絵のエディターが貧弱でつらいところ。
外部データのインポートは難しいにしても、せめて矩形選択しての移動はできるようになってほしい。
1ドットずつ、ちまちまと移動させていくのは悲しい作業であった。</p>

<h2>作品公開</h2>

<p>Nintendo Switch Online に入ってたら作品を一般公開できるのですが、他の人の良作を知る方法がほしくなります。
自分からアンテナ張ってる人にしか届けられない現状...。</p>

<p>ランキングがほしいなぁー...。
とはいえ、世間で人気なのは既存ゲームの再現系のグレーなものが多いので、やはりランキングを作ってしまうと削除対応をしなきゃいけなくなるから仕方がないのかなぁ...とは思います。</p>
]]></description>
		</item>

		<item>
			<title>小学一年生向けの「けいさんカード」アプリを作った話</title>
			<link>http://tech.nitoyon.com/ja/blog/2021/10/19/calc-card/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2021/10/19/calc-card/</guid>
			<pubDate>Tue, 19 Oct 2021 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>子どもが小学校に入学して、毎日、ちょっとした宿題が出るわけですが、その中でちょっと手間がかかったのが <strong>計算カードの宿題</strong> でした。</p>

<p><center><img src="real-card.jpg" width="400" height="250" alt="けいさんカード (実物)"></center></p>

<p>こんな感じの計算カードの中から親が問題を選んで、子どもに答えていってもらう・・・という宿題です。</p>

<h1>どこが面倒なのか</h1>

<p>カードをあらかじめシャッフルしておくと、毎回同じ問題の並び順になってしまいます。</p>

<p>毎回シャッフルするのは面倒なので、適当にめくりながら出題してると、簡単な問題ばかり出たり、すでに出した問題が出てきたり・・・。</p>

<p>カードを使わずに自分で出題していくと、同じ問題を何度も出してしまったり、答えてもらったあとに自分が出した問題を覚えてなかったり・・・。</p>

<h1>アプリを探してみたけど見つからず</h1>

<p>面倒を解消すべく、よさそうなアプリを探してみました。</p>

<p>小学生の勉強をトータルでサポートするような本格的なものだったり、1年生の範囲を超えた問題も出てくるアプリだったり・・・はあったのですが、手ごろなものは見つかりませんでした。</p>

<h1>ないならば作ってみよう</h1>

<p>そんなわけで、ないならば自分で作ってしまうことにしました。</p>

<p><a href="https://nitoyon.github.io/1-10calc/">けいさんカードアプリ</a> からどうぞ。</p>

<p><center>
<a href="https://nitoyon.github.io/1-10calc/"><img src="title.jpg" width="200" height="354" alt="タイトル画面" border="1"></a><br>
<a href="https://nitoyon.github.io/1-10calc/">https://nitoyon.github.io/1-10calc/</a></center></p>

<p>Web で作ったので iPhone, iPad, Android, PC のどれでも動きます。</p>

<p>アプリのように使いたければ、ホーム画面に追加 (Android ならショートカットを作成) しておくのがオススメです。</p>

<h1>使いかた</h1>

<p>たとえば、「たしざん 1」 (10 までの足し算) を選ぶと、こんな感じの画面が出てきます。</p>

<p><center><img src="q.jpg" width="200" height="356" alt="問題"></center></p>

<p>正解を選ぶとと、ほめられます。</p>

<p><center><img src="ok.jpg" width="300" height="208" alt="正解!!"></center></p>

<p>すぐに反応があるのが面白くて、子どもは勝手にどんどん解いていってくれます。</p>

<p>同じ問題は出てこないし、開くたびに問題が出る順番は変わります。</p>

<h2>終わったら結果を確認してみよう</h2>

<p><em>[←]</em> で戻って、下の <em>[勉強結果を見る]</em> を選ぶと、その日の子どもの勉強の成果を確認できます。</p>

<p><center><img src="result.jpg" width="300" height="265" alt="勉強結果"></center></p>

<p>毎日やってるうちに、解くまでの時間が短くなったり、間違えが減ったりして、子どもの成長を実感できます。</p>

<p>日ごとのグラフを表示できたらカッコイイでしょうけど、さすがにそこまでは作っていません。</p>

<h1>子どもの反応は・・・</h1>

<p>子どもに渡すと、し操作に戸惑う様子もなく 1 人でどんどん解いていきました。スマホ ネイティブ世代・・・おそるべし。
スマホ育児は避けてきたので、合法的に親のスマホで遊べるのもうれしかったようです。</p>

<p>何日か繰り返すうちに飽きてはきましたが、それでもサクッと宿題が終わるのが最高です。親の手間も大幅に減っています。やるほうもやらせるほうも気軽になりました。</p>

<p>さらに、アプリに興味を持った下の子が、両手を使って指折り数えながら「たしざん」の問題に回答していく様子はとてもかわいらしかったです。6 以上の足し算がでてくると、周りに助けを求めていたのですが・・・。</p>

<h2>開発の裏側</h2>

<p>素材については、Font Awesome と絵文字を活用しました。この辺の素材を使えば、気軽にリッチっぽい見た目になるのが便利な時代であります。絵文字を使うと、機種や端末によって印象が変わってしまうのは悲しいところですが。</p>

<p>ライブラリーは jQuery を使っていたのですが、HTML の生成処理が面倒になってきたので、Vue.js 3 で作りなおしてみました。初めての Vue.js で戸惑ったものの、公式のチュートリアルがよくできていたので助かりました。</p>

<h1>まとめ</h1>

<p>子育ての面倒なところを、自分が持っている技術を使って解決した話でした。</p>

<p>もう一度 URL を載せておきます。<a href="https://nitoyon.github.io/1-10calc/">https://nitoyon.github.io/1-10calc/</a> です。どうぞご利用ください。</p>
]]></description>
		</item>

		<item>
			<title>Go 言語で宇宙旅行風のアニメーション GIF を作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2016/01/18/space-travel-animated-gif/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2016/01/18/space-travel-animated-gif/</guid>
			<pubDate>Mon, 18 Jan 2016 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>宇宙旅行風のアニメーション GIF を Golang で生成してみた。完成品はこちら。</p>

<p><img src="http://img.gifmagazine.net/gifmagazine/images/704479/original.gif" width="500" height="250" alt="宇宙旅行風 (463KB)"></p>

<p>ソースコードはこの記事の末尾に掲載しています。以下では使ったライブラリーやテクニックを簡単に説明します。</p>

<h1>draw2d を使って描画する</h1>

<p>Golang の標準ライブラリーだけでは複雑な図形を描画するのは難しいので、<a href="https://github.com/llgcode/draw2d">draw2d</a> を使ってみることにした。こいつを使えば、線とか弧とかベジェ曲線を描けるし、線の色や塗る色も設定できる。</p>

<p>次のコードでは、<code>draw2dimg</code> と <code>draw2dkit</code> を使って、#808080 の四角を描画する例。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "github.com/llgcode/draw2d/draw2dimg"
    "github.com/llgcode/draw2d/draw2dkit"
    "image"
    "image/color"
)

func main() {
    img := image.NewRGBA(image.Rect(0, 0, 200, 200))
    gc := draw2dimg.NewGraphicContext(img)

    // Draw rectangle (#808080)
    gc.SetFillColor(color.Gray{0x80})
    draw2dkit.Rectangle(gc, 50, 50, 100, 100)
    gc.Fill()
    gc.Close()
}
</code></pre></div>

<p><code>draw2dimg.NewGraphicContext</code> は引数に <code>image.RGBA</code> (透明度つきの RGB 画像) を渡す必要があるんだけど、アニメーション GIF を <code>gif.EncodeAll</code> で作るときには <code>image.Palettted</code> (パレットの色だけを使った画像) を渡さなきゃいけない。</p>

<p>つまり、draw2d でアニメーション GIF を作るには、次のような処理が必要になる。</p>

<ol>
<li><code>iamge.RBGA</code> を作る</li>
<li>draw2d を使って描画する</li>
<li><code>image.RBGA</code> を <code>image.Paletted</code> に変換する</li>
<li><code>gif.EncodeAll</code> に <code>[]*image.Paletted</code> を渡して、アニメーション GIF を作る</li>
</ol>

<h1><code>image.RBGA</code> を <code>image.Paletted</code> に変換する方法</h1>

<p>1 枚の GIF を生成する <code>gif.Encode</code> は自動的に <code>image.RBGA</code> を <code>image.Paletted</code> に変換するんだけど、アニメーション GIF を生成する <code>gif.EncodeAll</code> は変換してくれない。</p>

<p>なので、自分で変換処理を実装する必要がある。といっても、<code>gif.Encode</code> と同じように、標準ライブラリで用意された <code>draw.FloydSteinberg</code> を使って <a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89-%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%B3%E3%83%90%E3%83%BC%E3%82%B0%E3%83%BB%E3%83%87%E3%82%A3%E3%82%B6%E3%83%AA%E3%83%B3%E3%82%B0">フロイド-スタインバーグ・ディザリング</a> を使うと簡単。こんな風に。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "image"
    "image/color"
    "image/draw"
)

func main() {
    img := image.NewRGBA(image.Rect(0, 0, 200, 200))

    // パレットを準備 (#ffffff, #000000, #ff0000)
    var palette color.Palette = color.Palette{}
    palette = append(palette, color.White)
    palette = append(palette, color.Black)
    palette = append(palette, color.RGBA{0xff, 0x00, 0x00, 0xff})

    // ディザリングする
    pm := image.NewPaletted(img.Bounds(), palette)
    draw.FloydSteinberg.Draw(pm, img.Bounds(), img, image.ZP)
}
</code></pre></div>

<h1>ソースコード全体</h1>

<p>全部で 100 行になってます。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "github.com/llgcode/draw2d/draw2dimg"
    "github.com/llgcode/draw2d/draw2dkit"
    "image"
    "image/color"
    "image/draw"
    "image/gif"
    "math"
    "math/rand"
    "os"
)

var w, h float64 = 500, 250
var palette color.Palette = color.Palette{}
var zCycle float64 = 8
var zMin, zMax float64 = 1, 15

type Point struct {
    X, Y float64
}

type Circle struct {
    X, Y, Z, R float64
}

// ループするように星を描画する
func (c *Circle) Draw(gc *draw2dimg.GraphicContext, ratio float64) {
    z := c.Z - ratio*zCycle

    for z &lt; zMax {
        if z &gt;= zMin {
            x, y, r := c.X/z, c.Y/z, c.R/z
            gc.SetFillColor(color.White)
            gc.Fill()
            draw2dkit.Circle(gc, w/2+x, h/2+y, r)
            gc.Close()
        }
        z += zCycle
    }
}

func drawFrame(circles []Circle, ratio float64) *image.Paletted {
    img := image.NewRGBA(image.Rect(0, 0, int(w), int(h)))
    gc := draw2dimg.NewGraphicContext(img)

    // 背景を描画
    gc.SetFillColor(color.Gray{0x11})
    draw2dkit.Rectangle(gc, 0, 0, w, h)
    gc.Fill()
    gc.Close()

    // 星を描画
    for _, circle := range circles {
        circle.Draw(gc, ratio)
    }

    // ディザリングする
    pm := image.NewPaletted(img.Bounds(), palette)
    draw.FloydSteinberg.Draw(pm, img.Bounds(), img, image.ZP)
    return pm
}

func main() {
    // 4000 個の星を準備
    circles := []Circle{}
    for len(circles) &lt; 4000 {
        x, y := rand.Float64()*8-4, rand.Float64()*8-4
        if math.Abs(x) &lt; 0.5 &amp;&amp; math.Abs(y) &lt; 0.5 {
            continue
        }
        z := rand.Float64() * zCycle
        circles = append(circles, Circle{x * w, y * h, z, 5})
    }

    // パレットを準備 (#000000, #111111, ..., #ffffff)
    palette = color.Palette{}
    for i := 0; i &lt; 16; i++ {
        palette = append(palette, color.Gray{uint8(i) * 0x11})
    }

    // 30 個の画像を作成
    var images []*image.Paletted
    var delays []int
    count := 30
    for i := 0; i &lt; count; i++ {
        pm := drawFrame(circles, float64(i)/float64(count))
        images = append(images, pm)
        delays = append(delays, 4)
    }

    // gif を出力
    f, _ := os.OpenFile("space.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
}
</code></pre></div>
]]></description>
		</item>

		<item>
			<title>Go 言語でアニメーション GIF を作成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</guid>
			<pubDate>Thu, 07 Jan 2016 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Golang でアニメーション GIF を作る手順を 3 通り紹介します。</p>

<ul>
<li>フレームごとの画像から生成</li>
<li>ビデオから生成</li>
<li>Go 言語で最初から生成</li>
</ul>

<h1>フレームごとの画像から生成</h1>

<p>こんな GIF 画像があったとします (<a href="http://qiita.com/mattn/items/b7889e3c036b408ae8bd">ここ</a> より拝借)。</p>

<p><img src="/ja/blog/2016/01/07/go-animated-gif-gen/g1.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g2.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g3.gif" width="200" height="200"></p>

<p>変換結果はこんな感じ。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/gopher.gif" width="200" height="200"></center></p>

<p>生成するためのコードはこんな感じ。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import "image"
import "image/gif"
import "os"

func main() {
    files := []string{"g1.gif", "g2.gif","g3.gif", "g2.gif"}

    // 各フレームの画像を GIF で読み込んで outGif を構築する
    outGif := &amp;gif.GIF{}
    for _, name := range files {
        f, _ := os.Open(name)
        inGif, _ := gif.Decode(f)
        f.Close()

        outGif.Image = append(outGif.Image, inGif.(*image.Paletted))
        outGif.Delay = append(outGif.Delay, 0)
    }

    // out.gif に保存する
    f, _ := os.OpenFile("out.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, outGif)
}
</code></pre></div>

<p>注意したいポイントは次の通り。</p>

<ul>
<li>フレームの GIF を順番に <code>gif.Decode</code> で読み込んでいる。JPEG から生成するには、GIF への変換処理を実装する必要がある (<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> では <code>gif.Encode</code> と <code>gif.Decode</code> を呼んで変換している)。</li>
<li>GIF アニメーションを生成するには <code>gif.EncodeAll</code> を呼ぶ。</li>
</ul>

<h1>ビデオから生成</h1>

<p><a href="http://www.mplayerhq.hu/">MPlayer</a> を使って各フレームの画像を抽出してから、<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> で GIF アニメーションを生成する。MPlayer にもアニメーション GIF を生成する機能はあるようだが、ディザリングがしょぼいので、この方法がよいらしい (詳しくは <a href="http://srinathh.github.io/opensource/goanigiffy/">GoAniGiffy</a>  を参照)。</p>

<h1>Go 言語で最初から生成</h1>

<p>こんな感じのものを作ってみた。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/rgb.gif" width="240" height="240"></center></p>

<p>各フレームの画像を Go 言語で描画して <code>[]*image.Paletted</code> を作って、<code>gif.EncodeAll</code> に渡している。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">    var images []*image.Paletted
    var delays []int

    // 20 個の画像を生成して円を描く
    for step := 0; step &lt; 20; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        // 描画処理 (長いので省略)
    }

    // rgb.gif に保存する
    f, _ := os.OpenFile("rgb.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })

</code></pre></div>

<p>全体のコードはこんな感じ。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "image"
    "image/color"
    "image/gif"
    "math"
    "os"
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 240, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    circles := []*Circle{&amp;Circle{}, &amp;Circle{}, &amp;Circle{}}

    var palette = []color.Color{
        color.RGBA{0x00, 0x00, 0x00, 0xff},
        color.RGBA{0x00, 0x00, 0xff, 0xff},
        color.RGBA{0x00, 0xff, 0x00, 0xff},
        color.RGBA{0x00, 0xff, 0xff, 0xff},
        color.RGBA{0xff, 0x00, 0x00, 0xff},
        color.RGBA{0xff, 0x00, 0xff, 0xff},
        color.RGBA{0xff, 0xff, 0x00, 0xff},
        color.RGBA{0xff, 0xff, 0xff, 0xff},
    }

    var images []*image.Paletted
    var delays []int
    steps := 20
    for step := 0; step &lt; steps; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        θ := 2.0 * math.Pi / float64(steps) * float64(step)
        for i, circle := range circles {
            θ0 := 2 * math.Pi / 3 * float64(i)
            circle.X = hw - 40*math.Sin(θ0) - 20*math.Sin(θ0+θ)
            circle.Y = hh - 40*math.Cos(θ0) - 20*math.Cos(θ0+θ)
            circle.R = 50
        }

        for x := 0; x &lt; w; x++ {
            for y := 0; y &lt; h; y++ {
                img.Set(x, y, color.RGBA{
                    circles[0].Brightness(float64(x), float64(y)),
                    circles[1].Brightness(float64(x), float64(y)),
                    circles[2].Brightness(float64(x), float64(y)),
                    255,
                })
            }
        }
    }

    f, _ := os.OpenFile("rgb.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
}
</code></pre></div>

<p>以上です。</p>
]]></description>
		</item>

		<item>
			<title>Go 言語でソースコードから画像生成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</guid>
			<pubDate>Thu, 31 Dec 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Go 言語には画像生成する image パッケージが標準で入っている。imagemagick や GD を導入する必要がないので、気軽に画像を生成できて便利そうだったので試してみた。</p>

<p>ただ、標準ではピクセル単位で色を設定することしかできないので、線を引いたり色を塗ったりするには、何らかのライブラリーに頼る必要がある。</p>

<p>今回は、ライブラリーには頼らず、標準で提供されている機能だけでできることを試してみた。</p>

<h1>一番簡単な例</h1>

<p>簡単な画像を生成する例は次の通り。1つ点を打つだけの例。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import "image"
import "image/color"
import "image/png"
import "os"

func main() {
    // 100×50 の画像を作成する
    img := image.NewRGBA(image.Rect(0, 0, 100, 50))

    // (2, 3) に赤い点をうつ
    img.Set(2, 3, color.RGBA{255, 0, 0, 255})

    // out.png に保存する
    f, _ := os.OpenFile("out.png", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    png.Encode(f, img)
}
</code></pre></div>

<h1>もっと複雑な例</h1>

<p>こんな画像を生成してみる。</p>

<p><center><img src="rgb1.png" width="280" height="240"></center></p>

<p>コードはこうなった。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "fmt"
    "image"
    "image/color"
    "image/png"
    "math"
    "os"
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 280, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    r := 40.0
    θ := 2 * math.Pi / 3
    cr := &amp;Circle{hw - r*math.Sin(0), hh - r*math.Cos(0), 60}
    cg := &amp;Circle{hw - r*math.Sin(θ), hh - r*math.Cos(θ), 60}
    cb := &amp;Circle{hw - r*math.Sin(-θ), hh - r*math.Cos(-θ), 60}

    m := image.NewRGBA(image.Rect(0, 0, w, h))
    for x := 0; x &lt; w; x++ {
        for y := 0; y &lt; h; y++ {
            c := color.RGBA{
                cr.Brightness(float64(x), float64(y)),
                cg.Brightness(float64(x), float64(y)),
                cb.Brightness(float64(x), float64(y)),
                255,
            }
            m.Set(x, y, c)
        }
    }

    f, err := os.OpenFile("rgb.png", os.O_WRONLY|os.O_CREATE, 0600)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer f.Close()
    png.Encode(f, m)
}
</code></pre></div>

<p><code>Circle</code> 構造体を定義して、円の中に入っているかどうかを判定する処理をメソッドとして定義している。</p>

<p>ちょっとしたテクニックとして、色を決定する部分は次のようにしている。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">c := color.RGBA{
    cr.Brightness(float64(x), float64(y)),
    cg.Brightness(float64(x), float64(y)),
    cb.Brightness(float64(x), float64(y)),
    255,
}
</code></pre></div>

<p>赤い色の中のときは赤色成分は <code>255</code>、外のときは <code>0</code> としている。他の成分も同じ。</p>

<h1>周辺をぼかしてみる</h1>

<p>色がくっきりしすぎているので、画像の周りをぼかしてみた。</p>

<p><center><img src="rgb2.png" width="280" height="240"></center></p>

<p>円の中のときに <code>return 255</code> としていた部分を書きかえるだけでできた。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        // 円の外のとき
        return 0
    } else {
        // 円の中のとき
        return uint8((1 - math.Pow(d, 5)) * 255)
    }
}
</code></pre></div>

<p><code>math.Pow</code> で 5 乗しているのは、ぼけすぎないようにするための工夫。</p>
]]></description>
		</item>

	</channel>
</rss>