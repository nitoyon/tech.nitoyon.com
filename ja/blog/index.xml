<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Mon, 04 Nov 2019 10:33:44 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />


		<item>
			<title>Go 言語で宇宙旅行風のアニメーション GIF を作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2016/01/18/space-travel-animated-gif/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2016/01/18/space-travel-animated-gif/</guid>
			<pubDate>Mon, 18 Jan 2016 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>宇宙旅行風のアニメーション GIF を Golang で生成してみた。完成品はこちら。</p>

<p><img src="http://img.gifmagazine.net/gifmagazine/images/704479/original.gif" width="500" height="250" alt="宇宙旅行風 (463KB)"></p>

<p>ソースコードはこの記事の末尾に掲載しています。以下では使ったライブラリーやテクニックを簡単に説明します。</p>

<h1>draw2d を使って描画する</h1>

<p>Golang の標準ライブラリーだけでは複雑な図形を描画するのは難しいので、<a href="https://github.com/llgcode/draw2d">draw2d</a> を使ってみることにした。こいつを使えば、線とか弧とかベジェ曲線を描けるし、線の色や塗る色も設定できる。</p>

<p>次のコードでは、<code>draw2dimg</code> と <code>draw2dkit</code> を使って、#808080 の四角を描画する例。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "github.com/llgcode/draw2d/draw2dimg"
    "github.com/llgcode/draw2d/draw2dkit"
    "image"
    "image/color"
)

func main() {
    img := image.NewRGBA(image.Rect(0, 0, 200, 200))
    gc := draw2dimg.NewGraphicContext(img)

    // Draw rectangle (#808080)
    gc.SetFillColor(color.Gray{0x80})
    draw2dkit.Rectangle(gc, 50, 50, 100, 100)
    gc.Fill()
    gc.Close()
}
</code></pre></div>

<p><code>draw2dimg.NewGraphicContext</code> は引数に <code>image.RGBA</code> (透明度つきの RGB 画像) を渡す必要があるんだけど、アニメーション GIF を <code>gif.EncodeAll</code> で作るときには <code>image.Palettted</code> (パレットの色だけを使った画像) を渡さなきゃいけない。</p>

<p>つまり、draw2d でアニメーション GIF を作るには、次のような処理が必要になる。</p>

<ol>
<li><code>iamge.RBGA</code> を作る</li>
<li>draw2d を使って描画する</li>
<li><code>image.RBGA</code> を <code>image.Paletted</code> に変換する</li>
<li><code>gif.EncodeAll</code> に <code>[]*image.Paletted</code> を渡して、アニメーション GIF を作る</li>
</ol>

<h1><code>image.RBGA</code> を <code>image.Paletted</code> に変換する方法</h1>

<p>1 枚の GIF を生成する <code>gif.Encode</code> は自動的に <code>image.RBGA</code> を <code>image.Paletted</code> に変換するんだけど、アニメーション GIF を生成する <code>gif.EncodeAll</code> は変換してくれない。</p>

<p>なので、自分で変換処理を実装する必要がある。といっても、<code>gif.Encode</code> と同じように、標準ライブラリで用意された <code>draw.FloydSteinberg</code> を使って <a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%82%A4%E3%83%89-%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%B3%E3%83%90%E3%83%BC%E3%82%B0%E3%83%BB%E3%83%87%E3%82%A3%E3%82%B6%E3%83%AA%E3%83%B3%E3%82%B0">フロイド-スタインバーグ・ディザリング</a> を使うと簡単。こんな風に。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "image"
    "image/color"
    "image/draw"
)

func main() {
    img := image.NewRGBA(image.Rect(0, 0, 200, 200))

    // パレットを準備 (#ffffff, #000000, #ff0000)
    var palette color.Palette = color.Palette{}
    palette = append(palette, color.White)
    palette = append(palette, color.Black)
    palette = append(palette, color.RGBA{0xff, 0x00, 0x00, 0xff})

    // ディザリングする
    pm := image.NewPaletted(img.Bounds(), palette)
    draw.FloydSteinberg.Draw(pm, img.Bounds(), img, image.ZP)
}
</code></pre></div>

<h1>ソースコード全体</h1>

<p>全部で 100 行になってます。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "github.com/llgcode/draw2d/draw2dimg"
    "github.com/llgcode/draw2d/draw2dkit"
    "image"
    "image/color"
    "image/draw"
    "image/gif"
    "math"
    "math/rand"
    "os"
)

var w, h float64 = 500, 250
var palette color.Palette = color.Palette{}
var zCycle float64 = 8
var zMin, zMax float64 = 1, 15

type Point struct {
    X, Y float64
}

type Circle struct {
    X, Y, Z, R float64
}

// ループするように星を描画する
func (c *Circle) Draw(gc *draw2dimg.GraphicContext, ratio float64) {
    z := c.Z - ratio*zCycle

    for z &lt; zMax {
        if z &gt;= zMin {
            x, y, r := c.X/z, c.Y/z, c.R/z
            gc.SetFillColor(color.White)
            gc.Fill()
            draw2dkit.Circle(gc, w/2+x, h/2+y, r)
            gc.Close()
        }
        z += zCycle
    }
}

func drawFrame(circles []Circle, ratio float64) *image.Paletted {
    img := image.NewRGBA(image.Rect(0, 0, int(w), int(h)))
    gc := draw2dimg.NewGraphicContext(img)

    // 背景を描画
    gc.SetFillColor(color.Gray{0x11})
    draw2dkit.Rectangle(gc, 0, 0, w, h)
    gc.Fill()
    gc.Close()

    // 星を描画
    for _, circle := range circles {
        circle.Draw(gc, ratio)
    }

    // ディザリングする
    pm := image.NewPaletted(img.Bounds(), palette)
    draw.FloydSteinberg.Draw(pm, img.Bounds(), img, image.ZP)
    return pm
}

func main() {
    // 4000 個の星を準備
    circles := []Circle{}
    for len(circles) &lt; 4000 {
        x, y := rand.Float64()*8-4, rand.Float64()*8-4
        if math.Abs(x) &lt; 0.5 &amp;&amp; math.Abs(y) &lt; 0.5 {
            continue
        }
        z := rand.Float64() * zCycle
        circles = append(circles, Circle{x * w, y * h, z, 5})
    }

    // パレットを準備 (#000000, #111111, ..., #ffffff)
    palette = color.Palette{}
    for i := 0; i &lt; 16; i++ {
        palette = append(palette, color.Gray{uint8(i) * 0x11})
    }

    // 30 個の画像を作成
    var images []*image.Paletted
    var delays []int
    count := 30
    for i := 0; i &lt; count; i++ {
        pm := drawFrame(circles, float64(i)/float64(count))
        images = append(images, pm)
        delays = append(delays, 4)
    }

    // gif を出力
    f, _ := os.OpenFile("space.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
}
</code></pre></div>
]]></description>
		</item>

		<item>
			<title>Go 言語でアニメーション GIF を作成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2016/01/07/go-animated-gif-gen/</guid>
			<pubDate>Thu, 07 Jan 2016 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Golang でアニメーション GIF を作る手順を 3 通り紹介します。</p>

<ul>
<li>フレームごとの画像から生成</li>
<li>ビデオから生成</li>
<li>Go 言語で最初から生成</li>
</ul>

<h1>フレームごとの画像から生成</h1>

<p>こんな GIF 画像があったとします (<a href="http://qiita.com/mattn/items/b7889e3c036b408ae8bd">ここ</a> より拝借)。</p>

<p><img src="/ja/blog/2016/01/07/go-animated-gif-gen/g1.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g2.gif" width="200" height="200">
<img src="/ja/blog/2016/01/07/go-animated-gif-gen/g3.gif" width="200" height="200"></p>

<p>変換結果はこんな感じ。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/gopher.gif" width="200" height="200"></center></p>

<p>生成するためのコードはこんな感じ。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import "image"
import "image/gif"
import "os"

func main() {
    files := []string{"g1.gif", "g2.gif","g3.gif", "g2.gif"}

    // 各フレームの画像を GIF で読み込んで outGif を構築する
    outGif := &amp;gif.GIF{}
    for _, name := range files {
        f, _ := os.Open(name)
        inGif, _ := gif.Decode(f)
        f.Close()

        outGif.Image = append(outGif.Image, inGif.(*image.Paletted))
        outGif.Delay = append(outGif.Delay, 0)
    }

    // out.gif に保存する
    f, _ := os.OpenFile("out.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, outGif)
}
</code></pre></div>

<p>注意したいポイントは次の通り。</p>

<ul>
<li>フレームの GIF を順番に <code>gif.Decode</code> で読み込んでいる。JPEG から生成するには、GIF への変換処理を実装する必要がある (<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> では <code>gif.Encode</code> と <code>gif.Decode</code> を呼んで変換している)。</li>
<li>GIF アニメーションを生成するには <code>gif.EncodeAll</code> を呼ぶ。</li>
</ul>

<h1>ビデオから生成</h1>

<p><a href="http://www.mplayerhq.hu/">MPlayer</a> を使って各フレームの画像を抽出してから、<a href="https://github.com/srinathh/goanigiffy">goanigiffy</a> で GIF アニメーションを生成する。MPlayer にもアニメーション GIF を生成する機能はあるようだが、ディザリングがしょぼいので、この方法がよいらしい (詳しくは <a href="http://srinathh.github.io/opensource/goanigiffy/">GoAniGiffy</a>  を参照)。</p>

<h1>Go 言語で最初から生成</h1>

<p>こんな感じのものを作ってみた。</p>

<p><center><img src="/ja/blog/2016/01/07/go-animated-gif-gen/rgb.gif" width="240" height="240"></center></p>

<p>各フレームの画像を Go 言語で描画して <code>[]*image.Paletted</code> を作って、<code>gif.EncodeAll</code> に渡している。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">    var images []*image.Paletted
    var delays []int

    // 20 個の画像を生成して円を描く
    for step := 0; step &lt; 20; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        // 描画処理 (長いので省略)
    }

    // rgb.gif に保存する
    f, _ := os.OpenFile("rgb.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })

</code></pre></div>

<p>全体のコードはこんな感じ。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "image"
    "image/color"
    "image/gif"
    "math"
    "os"
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 240, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    circles := []*Circle{&amp;Circle{}, &amp;Circle{}, &amp;Circle{}}

    var palette = []color.Color{
        color.RGBA{0x00, 0x00, 0x00, 0xff},
        color.RGBA{0x00, 0x00, 0xff, 0xff},
        color.RGBA{0x00, 0xff, 0x00, 0xff},
        color.RGBA{0x00, 0xff, 0xff, 0xff},
        color.RGBA{0xff, 0x00, 0x00, 0xff},
        color.RGBA{0xff, 0x00, 0xff, 0xff},
        color.RGBA{0xff, 0xff, 0x00, 0xff},
        color.RGBA{0xff, 0xff, 0xff, 0xff},
    }

    var images []*image.Paletted
    var delays []int
    steps := 20
    for step := 0; step &lt; steps; step++ {
        img := image.NewPaletted(image.Rect(0, 0, w, h), palette)
        images = append(images, img)
        delays = append(delays, 0)

        θ := 2.0 * math.Pi / float64(steps) * float64(step)
        for i, circle := range circles {
            θ0 := 2 * math.Pi / 3 * float64(i)
            circle.X = hw - 40*math.Sin(θ0) - 20*math.Sin(θ0+θ)
            circle.Y = hh - 40*math.Cos(θ0) - 20*math.Cos(θ0+θ)
            circle.R = 50
        }

        for x := 0; x &lt; w; x++ {
            for y := 0; y &lt; h; y++ {
                img.Set(x, y, color.RGBA{
                    circles[0].Brightness(float64(x), float64(y)),
                    circles[1].Brightness(float64(x), float64(y)),
                    circles[2].Brightness(float64(x), float64(y)),
                    255,
                })
            }
        }
    }

    f, _ := os.OpenFile("rgb.gif", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    gif.EncodeAll(f, &amp;gif.GIF{
        Image: images,
        Delay: delays,
    })
}
</code></pre></div>

<p>以上です。</p>
]]></description>
		</item>

		<item>
			<title>Go 言語でソースコードから画像生成する</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/12/31/go-image-gen/</guid>
			<pubDate>Thu, 31 Dec 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Go 言語には画像生成する image パッケージが標準で入っている。imagemagick や GD を導入する必要がないので、気軽に画像を生成できて便利そうだったので試してみた。</p>

<p>ただ、標準ではピクセル単位で色を設定することしかできないので、線を引いたり色を塗ったりするには、何らかのライブラリーに頼る必要がある。</p>

<p>今回は、ライブラリーには頼らず、標準で提供されている機能だけでできることを試してみた。</p>

<h1>一番簡単な例</h1>

<p>簡単な画像を生成する例は次の通り。1つ点を打つだけの例。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import "image"
import "image/color"
import "image/png"
import "os"

func main() {
    // 100×50 の画像を作成する
    img := image.NewRGBA(image.Rect(0, 0, 100, 50))

    // (2, 3) に赤い点をうつ
    img.Set(2, 3, color.RGBA{255, 0, 0, 255})

    // out.png に保存する
    f, _ := os.OpenFile("out.png", os.O_WRONLY|os.O_CREATE, 0600)
    defer f.Close()
    png.Encode(f, img)
}
</code></pre></div>

<h1>もっと複雑な例</h1>

<p>こんな画像を生成してみる。</p>

<p><center><img src="rgb1.png" width="280" height="240"></center></p>

<p>コードはこうなった。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">package main

import (
    "fmt"
    "image"
    "image/color"
    "image/png"
    "math"
    "os"
)

type Circle struct {
    X, Y, R float64
}

func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        return 0
    } else {
        return 255
    }
}

func main() {
    var w, h int = 280, 240
    var hw, hh float64 = float64(w / 2), float64(h / 2)
    r := 40.0
    θ := 2 * math.Pi / 3
    cr := &amp;Circle{hw - r*math.Sin(0), hh - r*math.Cos(0), 60}
    cg := &amp;Circle{hw - r*math.Sin(θ), hh - r*math.Cos(θ), 60}
    cb := &amp;Circle{hw - r*math.Sin(-θ), hh - r*math.Cos(-θ), 60}

    m := image.NewRGBA(image.Rect(0, 0, w, h))
    for x := 0; x &lt; w; x++ {
        for y := 0; y &lt; h; y++ {
            c := color.RGBA{
                cr.Brightness(float64(x), float64(y)),
                cg.Brightness(float64(x), float64(y)),
                cb.Brightness(float64(x), float64(y)),
                255,
            }
            m.Set(x, y, c)
        }
    }

    f, err := os.OpenFile("rgb.png", os.O_WRONLY|os.O_CREATE, 0600)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer f.Close()
    png.Encode(f, m)
}
</code></pre></div>

<p><code>Circle</code> 構造体を定義して、円の中に入っているかどうかを判定する処理をメソッドとして定義している。</p>

<p>ちょっとしたテクニックとして、色を決定する部分は次のようにしている。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">c := color.RGBA{
    cr.Brightness(float64(x), float64(y)),
    cg.Brightness(float64(x), float64(y)),
    cb.Brightness(float64(x), float64(y)),
    255,
}
</code></pre></div>

<p>赤い色の中のときは赤色成分は <code>255</code>、外のときは <code>0</code> としている。他の成分も同じ。</p>

<h1>周辺をぼかしてみる</h1>

<p>色がくっきりしすぎているので、画像の周りをぼかしてみた。</p>

<p><center><img src="rgb2.png" width="280" height="240"></center></p>

<p>円の中のときに <code>return 255</code> としていた部分を書きかえるだけでできた。</p>

<div class="highlight"><pre><code class="language-go" data-lang="go">func (c *Circle) Brightness(x, y float64) uint8 {
    var dx, dy float64 = c.X - x, c.Y - y
    d := math.Sqrt(dx*dx+dy*dy) / c.R
    if d &gt; 1 {
        // 円の外のとき
        return 0
    } else {
        // 円の中のとき
        return uint8((1 - math.Pow(d, 5)) * 255)
    }
}
</code></pre></div>

<p><code>math.Pow</code> で 5 乗しているのは、ぼけすぎないようにするための工夫。</p>
]]></description>
		</item>

		<item>
			<title>Visual Studio Code は JavaScript 開発が超絶便利になる可能性を秘めている！</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/11/20/try-vscode/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/11/20/try-vscode/</guid>
			<pubDate>Fri, 20 Nov 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>クロスプラットフォームでオープンソースな IDE 環境、<a href="https://code.visualstudio.com/">Visual Studio Code</a> が公開されたので試してみた。</p>

<p>拡張を入れなくても、デフォルトで JavaScript の「自動 Lint」「Grunt、Gulp 連携」「デバッグ」が動いた。なんだかすごく便利そうな予感。</p>

<p>Windows 環境で起動してみたらこんな画面だった。</p>

<p><center><img src="https://farm6.staticflickr.com/5728/22827535010_6c3f9d80da_z_d.jpg" width="500" height="384"></center></p>

<p>なんか黒いが、色は好みにカスタマイズできるし、プリセットからも選べる。</p>

<h1>フォルダーを開くことから始まる</h1>

<p>Visual Studio Code にはプロジェクトの概念はない。</p>

<p>[File] &gt; [Open Folder] からフォルダーを開けばよい。</p>

<p>ためしに、過去に作った Node.js 製の <a href="https://github.com/nitoyon/livereloadx">livereloadx</a> のフォルダーを開いてみた。</p>

<p><center><img src="https://farm1.staticflickr.com/684/22525086774_635323dd04.jpg" width="500" height="372"></center></p>

<p>左側にツリーが表示されている。プロジェクト内のファイルを開くにはツリー上でクリックしてもいいし、<code>Ctrl+P</code> を押せば、ファイル名でインクリメンタル検索できる (上の図では <code>fi</code> と入力しているので、<code>filter.js</code> や <code>config.js</code> が引っかかってる)。</p>

<p>ファイル内の文字列で検索するには、左の虫眼鏡を押すか、<code>Ctrl+Shift+F</code> から。</p>

<h1>自動 Lint</h1>

<p>左下の警告マークのところに 4 と出てるのでクリックしてみると、<code>Buffer</code> とか <code>__dirname</code> が見つからないといわれた。</p>

<p><center><img src="https://farm6.staticflickr.com/5661/22755770339_70279498fa.jpg" width="500" height="326"></center></p>

<p>警告をクリックして、電球マークをクリックすると、「<code>node.d.ts</code> をダウンロードする」というオプションがでてきた。</p>

<p><center><img src="https://farm6.staticflickr.com/5724/22729696698_2a9cd7fd7f.jpg" width="500" height="126"></center></p>

<p><code>d.ts</code> は TypeScript の型定義ファイル。これの Node.js 用を自動的に落とせるようだ。</p>

<p>落とすと警告は減った。が・・・本当に対処したほうがいいやつが出てきた・・・。</p>

<p><center><img src="https://farm1.staticflickr.com/703/22827902400_6bcc58719d.jpg" width="500" height="231"></center></p>

<p>ESLint と JSHint に<a href="https://code.visualstudio.com/docs/languages/javascript#_javascript-linters-eslint-jshint">対応している</a>らしい。</p>

<h1>Git 連携！</h1>

<p>コードを修正すると、左側の Git マークのところに数字が！</p>

<p>Git マークを押すと、最後のコミットから変更されたファイルが出てくる。<code>git status</code> の GUI 版みたいな感じ。</p>

<p><center><img src="https://farm1.staticflickr.com/762/23159649771_89618bc4da.jpg" width="500" height="357"></center></p>

<p>ファイルを選択すると差分が分かるし、＋マークを押すと <code>git add</code> するし、矢印を押すと変更を破棄できる。上の部分にメッセージを書くとコミットできる。</p>

<p>Git フレンドリー！</p>

<h1>Grunt, Gulp 連携</h1>

<p><code>Ctrl+Shift+T</code> を押すと、何も設定してないのに単体テストが走った!!</p>

<p><center><img src="https://farm6.staticflickr.com/5671/22729591857_d052424b76.jpg" width="500" height="391"></center></p>

<p>右側に単体テストの結果が表示されている。</p>

<p>理由は <code>Gruntfile.js</code> に <code>test</code> というタスクが登録してあるから。Visual Studio Code さんは、Grunt や Gulp、Jake のタスクを自動的に解釈してくれているのだ。</p>

<p>他にも <code>build</code> というタスクがあれば、<code>Ctrl+Shift+B</code> でビルドが走るらしい。カッコイイ。</p>

<p>もちろん、それ以外のタスクも開始できる。</p>

<p><code>F1</code> から <code>Run Task</code> を入力すると、実行できるタスクの一覧が出てくる。ためしに、<code>watch</code> タスクを選択すると、IDE 内において「編集したら、Lint して単体テスト、結果を表示」というフローが実現できた。カッコイイ。</p>

<p><center><img src="https://farm1.staticflickr.com/741/22828175870_7aa3f707a3.jpg" width="500" height="391"></center></p>

<h1>デバッグ!!!</h1>

<p>コードの適当なところに <code>F9</code> でブレークポイントを設定して、<code>F5</code> でデバッグを開始してみる。</p>

<p><center><img src="https://farm1.staticflickr.com/772/22827919780_706feaecf0.jpg" width="500" height="134"></center></p>

<p>「Node.js と Mono のどっちをデバッグする？」と聞かれた。<a href="https://marketplace.visualstudio.com/vscode/Debuggers">拡張</a>を入れたら他の言語もデバッグできるらしい。</p>

<p>ここでは Node.js を選ぶ。</p>

<p><code>.vscode/launch.json</code> が開くので、ここで何をデバッグするか設定する。</p>

<p><center><img src="https://farm1.staticflickr.com/581/22729605137_caeedb1cca.jpg" width="500" height="316"></center></p>

<p><code>program</code> のところで開始する JS ファイルを指定してみた。</p>

<p>再度、F5 でデバッグを始める。</p>

<p><center><img src="https://farm1.staticflickr.com/768/23134119082_5caca8673f.jpg" width="500" height="357"></center></p>

<p>ブレークポイントで止まった。</p>

<p>左上の Variables にはローカル変数やクロージャー内の変数の値が出てくる。左下にはスタックトレースがある。</p>

<p><code>F10</code> でステップオーバー、<code>F11</code> でステップイン、<code>Shift+F11</code> でステップアウトできるのは Visual Studio と同じ。</p>

<h1>他にも機能はたくさん</h1>

<p>まだまだ確認しきれていないが、機能はたくさんあるようだ。</p>

<ul>
<li>TypeScript なら変数名の変更やシンボル名での検索にも対応してるらしい。</li>
<li>コードスニペットは、特定の文字を入力して、Tab を押したら定型文を挿入してくれるので便利そう。</li>
<li>CSS (Sass, Less) にも対応してる。Lint するし、<code>Ctrl+Shift+O</code> でシンボルに飛べる。</li>
<li>この記事の Markdown を Visual Studio Code で書いているが、<code>Ctrl+V</code> でプレビューできる。</li>
</ul>

<p>言語ごとに何ができるかは、<a href="https://code.visualstudio.com/docs/languages/overview">ドキュメント</a> の LANGUAGES の中をみると一通り書いてある。</p>

<p>エディターとしての機能はまだ確認しきれていない。Windows なら日本語は問題なく通る。折り返しできない (?) のが、今この記事を書いていて不便に感じる。動作はサクサクしている。</p>

<p>(追記) Workspace Settings から <code>&quot;editor.wrappingColumn&quot;</code> の値を変えたら、折り返し幅も変わった。</p>

<h1>雑感</h1>

<p>ここまでの機能がデフォルトで有効になっている、というのはなかなかの衝撃であった。</p>

<p>ほめちぎりすぎたので、最後に悪いところも書いておく。</p>

<p>現状の Visual Studio Code は、メインメニューやコンテキストメニューが状況に応じて変化しない。便利な機能を使うためには、ショートカットキーを覚えるのが前提になっている。ドキュメントを読まないと何ができるのか見当つかないし、ショートカットを覚えるコストも高い。</p>

<p><a href="https://code.visualstudio.com/docs/">公式のドキュメント</a>はよくできているので、一通り読めば分かるんだけど、言語ごとに使える機能に違いがあるので、そのあたりもややこしい。</p>

<p>自分は Visual Studio を普段使いしてるので、慣れてるショートカットキーがそのまま使えて、手触りはとてもよかった。</p>
]]></description>
		</item>

		<item>
			<title>Object.observe の死 (ECMAScript の提案取り下げ、V8 からも削除予定)</title>
			<link>http://tech.nitoyon.com/ja/blog/2015/11/18/death-of-oo/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2015/11/18/death-of-oo/</guid>
			<pubDate>Wed, 18 Nov 2015 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>1年前の記事 <a href="/ja/blog/2014/07/18/data-binding/">JavaScript フレームワークがデータバインディングを実現する４通りの手法</a> では、<code>Object.observe()</code> について次のように説明した。</p>

<ul>
<li>JavaScript オブジェクトが変更されたときにコールバックを呼んでくれる API</li>
<li>データバインディングの実装が簡単になる</li>
<li>Google Chrome には実装済み</li>
<li>ECMAScript 7 に提案中</li>
<li>提案が通れば MV* フレームワークの実装がシンプルになってハッピー</li>
</ul>

<p>将来を期待されていた <code>Object.observe()</code> であったが、2015 年 11 月頭、ES Discuss メーリングリストへの <a href="https://esdiscuss.org/topic/an-update-on-object-observe">An update on Object.observe</a> という投稿で、ECMAScript からの提案が取り下げられて、V8 エンジンからも年内に削除される予定であることが表明された。</p>

<h1>Object.observe() に何があったのか</h1>

<p>メーリングリストへの投稿をざっくりと訳してみた。</p>

<blockquote>
<p>3年前、Rafael Weinstein、Erik Arvidsson、私 (Adam Klein) で、データバインディングを実現するための API を設計し始めた。V8 上のブランチでプロトタイプを作成したあと、V8 チームに正式版を開発することを認めてもらった。さらに、Object.observe (以下、&quot;O.o&quot; と表記) を ES7 標準に提案しつつ、Polymer チームと協力して O.o を使ってデータバインディングを実装した。</p>

<p>3年後、世界は大きく変わった。Ember や Angular といったフレームワークは O.o に興味を示したものの、既存のモデルを O.o のモデルに発展させるのは難しかった。Polymer は 1.0 をリリースするにあたりゼロから書き直されたが、そこでは O.o は使われなかった。さらに、React のような、データバインディングでミュータブルなものを避けようとする処理モデルが人気を博している。</p>

<p>関係者との議論の末、Object.observe の提案を TC39 (現在、ES 仕様策定のステージ 2) から取り下げることにした。また、今年の終わりまでには V8 でのサポートを終了したいと考えている (<a href="https://www.chromestatus.com/metrics/feature/popularity">chromestatus.com</a> によると、Chrome がアクセスしたページのうち 0.0169% でしか O.o は利用されていない)。</p>

<p>O.o を使っていた開発者は、<a href="https://github.com/MaxArt2501/object-observe">object-observe</a> のような polyfill や <a href="https://github.com/polymer/observe-js">observe-js</a> のようなラッパーライブラリーを使うことを検討してほしい。</p>
</blockquote>

<p><code>Object.observe()</code> は他のフレームワークで使われることもなかったし、Polymer でも使われなくなってしまったので、ECMAScript への提案を取り下げる、ということのようだ。</p>

<h1>Polymer 1.0 のデータバインディング実現方法</h1>

<p>Polymer が <code>Object.observe()</code> を使わなくなった理由については、Polymer の開発にも関わっている Brian Chin さんから <a href="https://esdiscuss.org/topic/an-update-on-object-observe">スレッド</a> 内に次のような<a href="https://esdiscuss.org/topic/an-update-on-object-observe#content-4">コメントがでている</a>。</p>

<blockquote>
<p>O.o はプロパティーを変更したあと、非同期でコールバックが呼ばれるのがイケてなかった。Polymer 1.0 ではプロパティーを変更したら、すぐに変更が UI に反映されるので、利用者にも分かりやすくなっている。</p>
</blockquote>

<p>モデルを書きかえた瞬間に、UI に反映されるようにしたかった、というのがメインの理由のようだ。</p>

<p>「じゃ、Polymer は <code>Object.observe()</code> の代わりに何を使ってるの？」という質問に対しては、次のような<a href="https://esdiscuss.org/topic/an-update-on-object-observe#content-2">回答</a>が出ている。</p>

<blockquote>
<p>getter/setter を定義して、DOM イベントで伝搬させてるよ。詳しくは polymer-project.org を見てね。たとえば <a href="https://www.polymer-project.org/1.0/docs/devguide/properties.html#change-callbacks">ここ</a> とか <a href="https://www.polymer-project.org/1.0/docs/devguide/data-binding.html#change-notification-protocol">ここ</a> だよ</p>
</blockquote>

<p>ざっと上記のページを見た感じでは、次のような感じでデータバインディングに使うプロパティーを宣言しておくらしい。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  Polymer({
    is: 'custom-element',
    properties: {
      someProp: {
        type: String,
        notify: true
      }
    }
  });
</code></pre></div>

<p>スレッドには、他にも「ブラウザーでは使われないかもしれないけど、Node.js のエコシステムには大きな影響があるかもしれないから、そんなに急に削除しないでくれ」と Node.js の中の人が書き込んでいたり、「Firefox の <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/watch">Object.watch()</a> はデバッガーで使われてるからすぐに削除されることはないはず」といった書き込みがあったりして興味深い。</p>

<h1>まとめ</h1>

<p><code>Object.observe()</code> は ECMAScript 7 に入ることはなくなったので、他のブラウザーに 実装される可能性はなくなったし、Google Chrome でも近い将来、使えなくなるだろう。</p>
]]></description>
		</item>

	</channel>
</rss>