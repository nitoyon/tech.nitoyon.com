<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Thu, 27 Jun 2013 09:24:18 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>Node.js 0.12 では yield が使えるのでコールバック地獄にサヨナラできる話</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/27/node-yield/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/27/node-yield/</guid>
			<pubDate>Thu, 27 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Node.js の次のメジャーバージョン 0.12 で <code>yield</code> が使えるようになります。</p>

<p>そのおかげで、JavaScript のコールバック地獄に光が差し込むのです。ああ、さようなら、コールバック地獄。</p>

<h1>7 年ごしで実現した yield</h1>

<p>2006 年、Firefox 2 のリリースと同時に <code>yield</code> は JavaScript 界に<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/New_in_JavaScript/1.7">登場</a>しました。随分と前の話ですね。</p>

<p>登場した当時は JavaScript 界隈でけっこう話題になっていました。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/amachang/20060805/1154743229">JavaScript 1.7 の yield が凄すぎる件について - IT戦記</a></li>
<li><a href="http://piro.sakura.ne.jp/latest/blosxom/webtech/javascript/2006-08-07_yield.htm">Latest topics &gt; JavaScript 1.7のyield文ってなんじゃらほ - outsider reflex</a></li>
<li><a href="http://nanto.asablo.jp/blog/2006/08/12/481381">JavaScript 1.7 の新機能: Days on the Moon</a></li>
</ul>

<p>登場したときにはインパクト大きかったものの、結局 Firefox でしか使えない <code>yield</code> さんは忘れ去られていたわけです。</p>

<p>それがここにきて、<a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">ECMAScript 6 に yield が入る</a>ことが決定して、V8 に実装されました。となれば、V8 を使ってる Node.js でも自動的に利用できるようになった、という流れであります。</p>

<p>7 年の月日を経て、日の目を見たわけで胸が熱くなります。何はともあれ、Node.js の次のバージョンに <code>yield</code> がやってくるのであります。ヤァヤァヤァ。</p>

<h1>さようなら！ コールバック地獄</h1>

<p>ということで、Node.js の話です。</p>

<p>脱出する前に、皆さんに地獄を見てもらいましょう。</p>

<h2>これが地獄絵図だ！</h2>

<p>サンプルとして、簡単なスクリプトを書いてみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var fs = require(&#39;fs&#39;);

// カレント ディレクトリーのファイル一覧を取得する
fs.readdir(&#39;.&#39;, function(err, files) {
    // 先頭のファイルの中身を読み取る
    fs.readFile(files[0], &#39;utf-8&#39;, function(err, data) {
        // 読み取った結果を出力する
        console.log(data);
    });
});
</code></pre></div>
<p>ああ、美しきコールバック地獄。たった 3 つの処理をするだけなのに、コールバックが 2 つもあるわけです。</p>

<p>といっても、Node.js には <code>fs.readdirSync()</code> や <code>fs.readFileSync()</code> といった同期処理をする関数も用意されておりますが、コールバック地獄を再現するために、あえて非同期版を使っております。</p>

<h2>Deferred にすがりつく</h2>

<p>こういうコールバック地獄から逃げるための今までの定石は Deferred だったわけです。jQuery にも実装されてるアレです。</p>

<p>Node.js で Deferred といえば <a href="https://github.com/kriskowal/q">Q</a> が有名らしいので、Q を使って書き直してみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var fs = require(&#39;fs&#39;);
var Q = require(&#39;q&#39;);

Q.nfcall(fs.readdir, &#39;.&#39;)
.then(function(files) {
    return Q.nfcall(fs.readFile, files[0], &#39;utf-8&#39;);
})
.then(function(data) {
    console.log(data);
})
.done();
</code></pre></div>
<p>確かにコールバックの階層は押さえられたのですが、かえって読みにくくなったようにも感じます。Deferred をマスターしてしまえば極楽なのかもしれませんが、Deferred は学習コストがそこそこ高いと思うわけです。</p>

<p>また、コードもいまいちすっきりしません。<code>then()</code> でコールバックを繋げるために deferred を返しているのが、何とも読みにくい構造になっています。</p>

<p>Deferred にすがりつくと、一見、幸せになりそうなんだけど、数ヶ月後にソースを読んだときに、ただのコールバック地獄よりも一層深い奈落の底に叩き落される恐れすらあるわけです。</p>

<h2>yield の恩恵を体験する</h2>

<p>で、<code>yield</code> です。</p>

<p>生で <code>yield</code> を扱うのは面倒なので、ライブラリーの力を借りましょう。</p>

<p>Node.js 界で数々の著名モジュールを作ってる TJ Holowaychuk (visionmedia) さんが、さっそく <code>yield</code> を活用するための <a href="https://github.com/visionmedia/co/">co</a> というモジュールを作ってるので使わせてもらいます。</p>

<p>こうなるんだぜ。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var co = require(&#39;co&#39;);
var fs = require(&#39;fs&#39;);

co(function *() {
  var files = yield co.wrap(fs.readdir)(&#39;.&#39;);
  var data = yield co.wrap(fs.readFile)(files[0], &#39;utf-8&#39;);
  console.log(data);
});
</code></pre></div>
<p>同期処理っぽく書いていますが、実はコールバック地獄版と同じ処理になっています。</p>

<p>それぞれの処理で失敗したときには例外が飛ぶので、エラー処理もばっちりです。</p>

<p>ああ、幸せですね。夢が広がりんぐです。いままで面倒だった非同期処理がとっても気楽に書けるのであります。C# の <code>await</code> みたいなことができます。</p>

<p>あ、いちおう細かな点について触れときます。</p>

<ul>
<li>上のソースを実行するには、<a href="http://jenkins.nodejs.org/html/nightlies.html">Node.js の Nightlies builds</a> から v0.11 のバイナリーを拾ってきて、<code>node --harmony-generators foo.js</code> として実行する必要がある。</li>
<li>co の最新のソース (<a href="https://github.com/visionmedia/co/commit/5bd0169604e82c8f9900ad7b6edf95a5cb23df53">co@5bd0169</a>) は 48 行目の <code>gen.send(res);</code> でエラーになるので、<code>gen.next(res);</code> に書き換える必要がある。</li>
</ul>

<h1>yield について簡単に説明するよ</h1>

<p>いちおう <code>yield</code> が何か、という話を簡単に触れておきます。詳しくは <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">harmony:generators [ES Wiki]</a> を見てください (ちょっと情報が古いようですが…)。</p>

<p>シンプルな例を書いてみました。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">function* N() {
    console.log(&quot;start&quot;);
    yield 1;
    console.log(&quot;after 1&quot;);
    yield 2;
    console.log(&quot;after 2&quot;);
    return 3;
}
</code></pre></div>
<p>まず、<code>yield</code> を使う関数は <code>function</code> ではなく <code>function*</code> で宣言します。(Firefox の先行実装と少し違います)</p>

<p>で、この関数を呼んでみます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">var g = N();
console.log(g);
// {}
</code></pre></div>
<p><code>function*</code> な関数を呼んでも、関数の処理は始まりません。変わりに関数の処理を開始させるためのジェネレーターが返ってきます。</p>

<p>では、ジェネレーターを使ってみましょう。ジェネレーターの <code>next()</code> を呼ぶと、関数の処理を開始できます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// start
// { value: 1, done: false }
</code></pre></div>
<p><code>yield</code> は <code>return</code> みたいなもので戻り値を返します。ここでは、戻り値の <code>1</code> が <code>value</code> として返ってきています。</p>

<p><code>yield</code> と <code>return</code> の違い、それは、<code>yield</code> は続きから処理を再開できるところにあります。そう、<code>g.next()</code> を呼べばね。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// after 1
// { value: 2, done: false }
</code></pre></div>
<p><code>after 1</code> から処理が再開して、<code>2</code> を返して、再び、関数は中断しました。もう一度 <code>g.next()</code> を呼んでみます。</p>
<div class="highlight"><pre><code class="js language-js" data-lang="js">console.log(g.next());
// after 2
// { value: 3, done: true }
</code></pre></div>
<p><code>return</code> で関数が終わったので、<code>done</code> が <code>true</code> になりました。(この戻り値も Firefox の先行実装と異なります)</p>

<p>こんな感じで、<code>yield</code> を使えば、関数の処理を途中で中断しておくことができます。で、上の co を使ったサンプルを見たら・・・なんとなく実現できそうな気がしてきましたか？</p>

<h1>まとめ</h1>

<ul>
<li>ECMAScript 6 に <code>yield</code> が入った → V8 に実装 → Node.js 0.12 で使える</li>
<li><code>yield</code> を使えばコールバック地獄から脱出できる。</li>
<li>この記事では <a href="https://github.com/visionmedia/co/">co</a> を紹介したけど、便利ライブラリーはまだまだ登場しそう。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Jekyll で --watch の代わりに Grunt を使ってみるテスト</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/25/jekyll-grunt/</guid>
			<pubDate>Tue, 25 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>このブログでは <a href="https://github.com/mojombo/jekyll">Jekyll</a> を使ってることは何度か書いたのだけど、いままで記事を書くときには <code>jekyll --auto</code> を実行した状態で書いていた。このようにしておくと、ファイルを書き換えたら自動的にサイトをビルドしてくれるようになる。ただ、このコマンドを実行してると CPU がグオーンと音を上げ始め、クアッドコアで CPU 使用率 25% に達するという地球に優しくない状態であった。</p>

<p>原因を調べてみると <code>directory_watcher</code> モジュールが犯人だった。このモジュールは、監視対象のディレクトリー配下の全ファイルに対して、毎秒、<code>File::Stat()</code> を実行する、という富豪的実装になっている。もちろん、ファイルの数が少ないときには問題なく動くんだけども、ファイルの数が増えると CPU を浪費してしまう。</p>

<p>たとえば、このサイトの場合、600 個以上の記事があって、Jekyll が 900 個のファイルを生成する。しかも、<code>.git</code> フォルダーの下には 5,000 個程度のファイルがある。ひどいことに、Jekyll 0.12 までのバージョンは、これらのファイルすべてを監視対象にする。毎秒 6,500 個のファイルを stat するわけだから、当然、CPU は振り切る。</p>

<p>Jekyll 1.0 になって、コマンドも <code>jekyll build --watch</code> に変わって、<code>_site</code> (サイトの出力先) や <code>.git</code> が監視対象から外れたので、パフォーマンスはだいぶ改善した。それでも自分の環境で常時 10% ぐらい CPU を消費し続けている。</p>

<p>ということで、<code>--watch</code> (もしくは <code>--auto</code>) オプションの代わりに、流行の <a href="http://gruntjs.com/">Grunt</a> を使ってみることにした。</p>

<h1>Grunt の設定ファイル</h1>

<p>使っているバージョンやプラグインは次の通り。</p>

<ul>
<li>Jekyll 1.0.3</li>
<li>Grunt 0.4.1

<ul>
<li><code>grunt-shell-spawn</code> プラグイン</li>
<li><code>grunt-contrib-watch</code> プラグイン</li>
</ul></li>
</ul>

<p>最初は、<code>grunt-shell-spawn</code> ではなく <code>grunt-jekyll</code> を使ってたんだけど、<code>grunt-jekyll</code> は Jekyll を実行中の途中経過を表示してくれないので使うのをやめた。</p>

<p>Grunt の使い方については <a href="http://gruntjs.com/getting-started">Getting started - Grunt</a> を見たほうが早いだろうから、ここでは <code>package.json</code> と <code>Gruntfile.js</code> を紹介する。</p>

<h2>package.json</h2>
<div class="highlight"><pre><code class="json language-json" data-lang="json">{
  &quot;name&quot;: &quot;tech-ni&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-shell-spawn&quot;: &quot;~0.2.4&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;
  }
}
</code></pre></div>
<h2>Gruntfile.js</h2>
<div class="highlight"><pre><code class="js language-js" data-lang="js">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll: {
        command: &#39;jekyll build&#39;,
        options: {
          async: false
        }
      }
    },
    watch: {
      jekyll: {
        files: [&#39;_posts/**/*.md&#39;, &#39;_layout/*.html&#39;, &#39;_includes/*.html&#39;],
        tasks: [&#39;shell:jekyll&#39;]
      }
    }
  });

  grunt.loadNpmTasks(&#39;grunt-shell-spawn&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

  grunt.registerTask(&#39;default&#39;, [&#39;shell:jekyll&#39;]);
};
</code></pre></div>
<p>(Jekyll 0.12 までを使用している場合は、<code>jekyll build</code> を <code>jekyll</code> で置き換えるべし)</p>

<h1>使い方</h1>

<p><code>grunt watch</code> を実行すると、ファイルの監視を始める。記事や HTML が編集されたら、<code>jekyll build</code> が実行されるようになっている。</p>

<p>しかし、Jekyll で監視するよりも CPU 消費量は小さいが・・・0 ではない・・・!?　と、ここで調べてみて気づいたんだけども、Grunt の watch は、ネイティブ API の <code>fs.watch()</code> を使ってファイルを監視していない!!!　<code>gaze</code> モジュールを使って定期的にファイルを stat しているだけだった。</p>

<p>これでは Ruby の <code>directory_watcher</code> と同じである。</p>

<p>どうやら、Node.js の <code>fs.watch()</code> は Mac OS でファイル名を取れなかった過去があるなど、歴史的に不安定であり、結局、stat で独自に監視する、という手順が一般的になったようだ。なんという罠。</p>
]]></description>
		</item>

		<item>
			<title>ブログのタグ機能が復活したよ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/06/17/blog-tag/</guid>
			<pubDate>Mon, 17 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>昨年 9 月に<a href="/ja/blog/2012/09/20/moved-completed/">はてなダイアリーから引っ越した</a>ときにタグ機能が消えてしまっていたのですが、このたび、重い腰をあげて復活させました。</p>

<p>たとえばこの記事の場合、上側の日付の右にタグが 2 つあることにお気づきいただけるでしょうか。タグ名をクリックすると、そのタグがついた記事の一覧が表示できますよ。</p>

<p>ついでに、既存のタグも整理しています。統廃合したり、無意味なものを消したり。整理した結果がこの<a href="/ja/blog/tags/">タグ一覧</a>。</p>

<p><center><img src="http://farm8.staticflickr.com/7325/9056245193_eccb68e139.jpg" width="500" height="225"></center></p>

<p>トップページの記事一覧にもタグを表示するようにしました。</p>

<p><center><img src="http://farm8.staticflickr.com/7387/9055850365_dafbc8f937.jpg" width="500" height="348"></center></p>

<h1>Jekyll のタグ機能をカスタマイズ</h1>

<p><a href="/ja/blog/2012/09/20/moved-completed/">以前に書いた</a>とおり、このブログの出力には <a href="https://github.com/mojombo/jekyll/">Jekyll</a> を使っています。Jekyll 本体には、記事に<a href="/en/blog/2013/04/17/jekyll-pluralize/">タグを設定する機構</a>は用意されているのですが、タグの記事一覧を出力する機能がなくて、自前で実装する必要があります。</p>

<p>そこで、<a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/">blackbulletiv.github.com</a> さんの <a href="https://github.com/BlackBulletIV/blackbulletiv.github.com/blob/master/_plugins/tags_categories.rb">tags_categories.rb</a> を参考にしつつ、「日本語タグだけど URL は英語」「複数ブログ対応」といったあたりを実現するために、いろいろと手をいれてカスタマイズしています。</p>

<p>詳しくは、</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/tags.rb">tags.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/filters/tag_filter.rb">tag_filter.rb</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_config.yml">_config.yml</a></li>
</ul>

<p>あたりを見れば雰囲気が分かると思います。</p>

<h1>この後の野望</h1>

<p>このあとやってみたいことは・・・</p>

<ul>
<li>サイト内検索:<br>あると便利なのは間違いないし、検索向け AdSense というのがあるらしい。</li>
<li>サムネール:<br>各記事にサムネールを設定して、それを利用したデザインになると嬉しい。</li>
<li>Web フォント:<br>フラットなデザインが流行しつつあるので、Web フォントを使ったアイコンの利用率も増えてきそう。</li>
<li>2 カラム化:<br>スクロールすると固定するカラムには興味ある。せっかく 1 カラム化したのだけど・・・。</li>
<li>Jekyll 1.0 対応:<br>いつのまにか正式版が出ていたらしい。何が便利になったのか、まだ追えていない。</li>
</ul>

<p>そんなことより、もっと頻繁に記事を書けよ、という感じではありますが・・・。</p>
]]></description>
		</item>

		<item>
			<title>Bugzilla に登録してあるバグをプログラムから更新する方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/05/17/bugzilla-hack/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/05/17/bugzilla-hack/</guid>
			<pubDate>Fri, 17 May 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>会社で BTS として Bugzilla を使っているんだけど、修正したあとに手作業で Web インターフェースから書き込むのが面倒になってきたので、自動化してみた。</p>

<p>コミットしたとき (Git の場合は push したとき) に、コミットメッセージからバグ番号を読み取って、対応するバグにメッセージを書き込みつつ、FIXED にすればよい。</p>

<p>情報がなくて困ったのが、バグにコメントを書いたり、FIXED にする方法。この部分の処理を抜き出してみた。</p>
<div class="highlight"><pre><code class="perl language-perl" data-lang="perl">#!/usr/bin/perl -I/path/to/bugzilla -I/path/to/bugzilla/lib

use strict;
use Bugzilla;
use Bugzilla::User;
use Bugzilla::Status;
use Bugzilla::Bug;
use utf8;

&amp;update_bug(1, &quot;ほげほげ&quot;);

# API document: http://www.bugzilla.org/docs/4.2/en/html/api/
sub update_bug {
    my ($bug_id, $text) = @_;

    # open bug
    my $bug = Bugzilla::Bug-&gt;new($bug_id);
    die $bug-&gt;error if defined $bug-&gt;error;

    # get user
    my $user = Bugzilla::User-&gt;new({name =&gt; &#39;admin@example.com&#39;});
    die &#39;user not found!!!!&#39; unless defined $user;

    # login
    Bugzilla-&gt;set_user($user);

    # comment to the bug
    $bug-&gt;add_comment($text);

    # FIXED
    $bug-&gt;set_bug_status(Bugzilla::Status-&gt;new({name =&gt; &#39;RESOLVED&#39;}),
                         {resolution =&gt; &#39;FIXED&#39;});

    # save to database
    $bug-&gt;update();
}
</code></pre></div>
<p>Bugzilla 4.2.5 で動作を確認している。</p>

<p>あとは、Git なら <code>post-receive</code> フックで、コミットログを解析して、この関数を呼ぶようにすればよい。</p>

<p>注意点:</p>

<ul>
<li>Bugzilla がインストールされているサーバー上で動くことを前提としている。同一サーバーならパスワードなしで、特定のユーザーに su できるようだ。</li>
<li><code>Bugzilla::Bug</code> はドキュメント化されていないので、バージョンアップしたら使えなくなる可能性がある。同じような機能の <code>Bugzilla::WebService::Bug</code> はドキュメントがあるんだけど、使おうとしたら <code>Test/Taint.pm</code> が必要だとか言われて面倒になったのでやめた。</li>
</ul>
]]></description>
		</item>

		<item>
			<title>git commit --amend を省力化する方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/05/02/git-commit-amend/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/05/02/git-commit-amend/</guid>
			<pubDate>Thu, 02 May 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Git で最後のコミットを修正するときには <code>git commit --amend</code> を使うんだけども、いままでは</p>

<ol>
<li><code>git add .</code></li>
<li><code>git commit --amend</code></li>
<li>エディターが立ち上がって、前回のコミット メッセージが表示される</li>
<li>エディターを終了させる</li>
</ol>

<p>としていた。</p>

<p>この作業は何度も繰り返すと面倒だったので、man を調べてみると <code>--no-edit</code> なるステキなオプションを発見した。</p>

<h1>--no-edit を使う</h1>

<p><code>--no-edit</code> を指定すると、上の手順はこうなる。</p>

<ol>
<li><code>git add .</code></li>
<li><code>git commit --amend --no-edit</code></li>
</ol>

<p>コミット メッセージはそのままに、コミットの中身だけを書き換えられる。エディターが立ち上がらないので楽チン。</p>

<h1>-a でさらに省力化</h1>

<p>さらに <code>git add .</code> も省力化できて</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">git commit -a --amend --no-edit
</code></pre></div>
<p>とすればよい。</p>

<p><strong>コマンド一発</strong>になった。超楽チン。</p>

<p>注意点は次の 2 つ。</p>

<ul>
<li>新しいファイルを追加したときは明示的に add する必要がある。<code>git add .</code> と <code>git commit -a</code> ではステージするファイルが違うので注意。</li>
<li>コミットしたくない変更がワーキング ディレクトリーに残ってる状態では使えない。<code>git stash</code> するなどでよけておくべし。</li>
</ul>
]]></description>
		</item>

	</channel>
</rss>