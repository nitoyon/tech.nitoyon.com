<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Thu, 18 Oct 2012 00:58:49 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>ActionScript のみで作った SWF をコマ落ちせずに動画にする手法</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/10/18/as3-to-movie/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/10/18/as3-to-movie/</guid>
			<pubDate>Thu, 18 Oct 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>世の中には SWF を動画に変換するツールがいくつかある。</p>

<p>これらのツールは、SWF を再生しておいて、次々と画面をキャプチャしていって、最後に動画に変換する、というものがほとんどのようだ。変換の再現性は高い一方、どうしてもコマ落ちが発生してしまう。</p>

<p>ActionScript のみで作成した SWF を<strong>コマ落ちせずに動画に変換する</strong>テクニックを解説する。前提条件は、ソースコードが手元にあり、Flash IDE を利用していないこと、ActionScript の知識があること。</p>

<p><a href="http://wonderfl.net/">wonderfl</a> の作品を動画にする、と説明するとイメージが沸きやすいかもしれない。</p>

<h1>enterFrame だけで描画するパターン</h1>

<p>比較的簡単に変換できるのが、<code>enterFrame</code> イベントが発生するごとに描画するパターンのときである。</p>

<h2>変換例</h2>

<p>試しに、過去に wonderfl に投稿した <a href="http://wonderfl.net/c/mnwo/">キラキラ3D Typography</a> を動画に変換してみた。</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/2tm9okNtkOg" frameborder="0" allowfullscreen></iframe>


<h2>ソースコードについて</h2>

<p>ソースは <a href="https://gist.github.com/3885010">https://gist.github.com/3885010</a> に上げている。</p>

<p>肝は <code>PngOutput</code> という自作クラスだ。<code>enterFrame</code> のイベントごとに、<code>PngOutput.output()</code> メソッドを呼んで、表示している内容を png ファイルで書き出している。</p>

<div class="highlight"><pre><code class="actionscript">    <span class="c1">// ループ処理</span>
    <span class="nx">PngOutput</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">stage</span><span class="p">);</span>
    <span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;enterFrame&quot;</span><span class="o">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="o">:</span><span class="nb">Event</span><span class="p">)</span><span class="o">:</span><span class="nx">void</span><span class="p">{</span>
        <span class="c1">// ここで描画処理をしている</span>

        <span class="nx">PngOutput</span><span class="p">.</span><span class="nx">output</span><span class="p">();</span>
        <span class="nx">counter</span><span class="o">++;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">counter</span> <span class="o">%</span> <span class="mi">120</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">f</span> <span class="o">=</span> <span class="o">!</span><span class="nx">f</span><span class="o">;</span> <span class="p">}</span>
    <span class="p">});</span>
</code></pre>
</div>


<p>画像のサイズは <code>stage</code> のサイズを利用しているので、<code>SWF</code> メタタグやコンパイルオプションでサイズを指定できる。</p>

<p>ファイルを扱うために、AIR アプリとして実行している。<code>amxmlc</code> でビルドして、<code>adl app.xml</code> で画像出力を開始してくれるようになっている。出力先のパスは <code>PngOutput</code> クラスに直接書いてあるので、適切に変更して利用してほしい。</p>

<p>よくあるキャプチャして動画にするツールとは違って、コマ落ちは発生しない。というのも、<strong>1 フレームずつ、順番に「描画＋画像に変換」を実行している</strong>からだ。変換中は、ゆっくり 1 フレームずつ再生しながら画像出力しているが、できあがった画像をつなぎ合わせればコマ落ちが発生しない動画になっている。ソースコードが手中にあるからこそできる技である。</p>

<p>連番画像ファイルから動画への変換は AviUtil を使った。先頭の画像をドロップして、エンコードすればいいだけなのでお手軽だった。たいがいの動画変換ソフトが連番画像ファイルに対応しているだろうから、慣れているものを使って変換すればよいだろう。</p>

<h1>タイマーを参照するパターン</h1>

<p>さて、もう少し厄介なのが、各フレームでタイマーを参照するパターンの作品だ。そのようなコードを意識して書いていなかったとしても、トゥイーン系ライブラリでは内部的にタイマー系の関数を利用している。</p>

<p>このパターンの作品を、1つ目と同じように <code>enterFrame</code> で 1 フレームずつ画像出力していると、早送りの動画が出来上がってしまう。というのも、描画して画像を出力している間に、<code>1 / frameRate</code> 以上の時間が経過してしまうので、飛び飛びの画像しか出力できないのだ。</p>

<p>これを防ぐためには、トゥイーン ライブラリで利用しているタイマー系の関数を置き換えて騙すしかない。</p>

<h2>変換例</h2>

<p>過去に wonderfl に投稿した <a href="http://wonderfl.net/c/nCFQ">Hello World!!!</a> を動画にしてみた。</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/nI-u_XPbCTw" frameborder="0" allowfullscreen></iframe>


<h2>ソースコードについて</h2>

<p>ソースは <a href="https://gist.github.com/3885404">https://gist.github.com/3885404</a> に上げている。</p>

<p><a href="http://wonderfl.net/c/nCFQ">Hello World!!!</a> は Tweener を使ってアニメーションしている。Tweener は、ライブラリの内部で <code>flash.utils.getTimer()</code> を使って、時間管理を実施している。この部分を書き換えて、自前で定義した <code>getTimer()</code> 関数を呼ぶようにした。</p>

<p><code>enterFrame</code> で 1 フレームごとに画像を出力する点は以前のものと変わらない。ただ、画像を 1 枚出力するごとに、自前の <code>getTimer()</code> が返す値が <code>1 / frameRate</code> だけ増えるように細工している。結果、出力した秒数に応じた位置で Tweener のアニメーションが停止するようになる。よって、コマ落ちが発生しない。</p>

<p>フレームレートは <code>stage.frameRate</code> を利用しているので、コンパイルオプションや <code>SWF</code> メタタグでカスタマイズすれば、デフォルト以外のフレームレートでも出力できる。</p>

<p>自前の <code>getTimer()</code> をトップレベルのパッケージとして定義しているが、これは <code>flash.utils.getTimer()</code> を利用するライブラリを一緒にビルドしようとしたときに、ビルドエラーにさせるためである。<code>flash.utils.getTimer()</code> を利用している箇所を grep して見つけ出してもいいんだけど、コンパイラに見つけさせよう、という魂胆である。</p>

<h1>まとめ</h1>

<p>ActionScript のソースが手元にあるときに、コマ落ちなく動画に変換する方法を説明した。</p>

<p>今回は簡単なソースコードで説明したが、<code>setInterval()</code> を使ってるようなケースではさらに複雑になる。マウスインタラクションがあったり、外部 SWF をロードしていると太刀打ちできなくもなる。</p>

<p>応用事例になるが、リアルタイムではとてもじゃないけど再生できないような劇重 Flash を作成したとしても、この方法を使って動画に変換はできる。パーティクルをいくつ配置しようが、ポリゴンをいくつ配置しようが、HD 画質にしようが、動画にしてしまえばコマ落ちの心配はない。Flash Player では得られない高画質な動画を作ることもできるだろう。</p>

<p>ここで紹介した 2 つの作品は、<a href="http://www.amazon.co.jp/ActionScript-Beautifl-Code%E3%80%9CBeautifl-Gallery-wonderfl%E3%80%9C/dp/4862671098%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4862671098">ActionScript Beautifl Code〜Beautifl: Flash Gallery of wonderfl〜</a> で解説してもらっているので、興味がある人はそちらもどうぞ。</p>

<div class="hatena-asin-detail">
  <a href="http://www.amazon.co.jp/ActionScript-Beautifl-Code%E3%80%9CBeautifl-Gallery-wonderfl%E3%80%9C/dp/4862671098%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4862671098"><img src="http://ecx.images-amazon.com/images/I/51d7HQjkhbL._SL160_.jpg" class="hatena-asin-detail-image" alt="ActionScript Beautifl Code〜Beautifl: Flash Gallery of wonderfl〜" title="ActionScript Beautifl Code〜Beautifl: Flash Gallery of wonderfl〜"></a>
  <div class="hatena-asin-detail-info">
    <p class="hatena-asin-detail-title"><a href="http://www.amazon.co.jp/ActionScript-Beautifl-Code%E3%80%9CBeautifl-Gallery-wonderfl%E3%80%9C/dp/4862671098%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4862671098">ActionScript Beautifl Code〜Beautifl: Flash Gallery of wonderfl〜</a></p>
    <ul>
      <li><span class="hatena-asin-detail-label">作者:</span> 池田泰延</li>
      <li><span class="hatena-asin-detail-label">出版社/メーカー:</span> ワークスコーポレーション</li>
      <li><span class="hatena-asin-detail-label">発売日:</span> 2011-06-08</li>
      <li><span class="hatena-asin-detail-label">メディア:</span> 単行本</li>
      <li><a href="http://www.amazon.co.jp/review/product/4862671098%3FSubscriptionId%3DAKIAJTLVJPAVA2KR4PJA%26tag%3Dnitoyoncom-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D5143%26creativeASIN%3D4862671098">Amazon のレビューを見る</a></li>
    </ul>
  </div>
  <div class="hatena-asin-detail-foot"></div>
</div>

]]></description>
		</item>

		<item>
			<title>静的サイトで JS/CSS のキャッシュを防ぎつつレポジトリをキレイに保つ</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/10/15/static-site-js-css-cache/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/10/15/static-site-js-css-cache/</guid>
			<pubDate>Mon, 15 Oct 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>「<a href="/ja/about/">ABOUT</a>」のページをリニューアルしました。</p>

<p>１つ前のデザインのままだったものを、現在のデザインに沿って作りなおして、ついでに文章やレイアウトなども整えました。</p>

<center><a href=" /ja/about/ "><img src="http://farm9.staticflickr.com/8476/8086011433_ab8bb44953.jpg" width="500" height="410"></a></center>


<h1>公開したものの問題発生</h1>

<p>意気揚々と公開してみたのですが、１つ問題が見つかりました。</p>

<p>ページを公開したあと、本番環境を表示するとデザインが崩れていました。そのあと、ページをリロードすると期待通りの結果になりました。</p>

<p>原因は <strong>CSS がキャッシュされていた</strong> ことでした。</p>

<p>たとえページが更新されていたとしても、JavaScript や CSS は古いキャッシュを使い続けてしまうことがあります。</p>

<p>で、この問題に対処しようとしたのですが、「静的生成」「生成結果を GitHub で管理」「キャッシュ問題への対策」の 3 つのいいとこ取りをしようとすると、意外に複雑でした。</p>

<p>その話をいまからします。</p>

<h1>キャッシュ問題の一般的な解決策</h1>

<p>よく見る解決索は、JS や CSS の URL の最後に、URL パラメーターとしてタイムスタンプを入れておく方法です。</p>

<div class="highlight"><pre><code class="html"><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;/stylesheets/foo.css?1348129300&quot;</span> <span class="err">...</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;/javascripts/bar.js?1282104010&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre>
</div>


<p>このようにすると、次のような効果が期待できます。</p>

<ul>
<li>JavaScript や CSS が更新されたとき:

<ul>
<li>タイムスタンプが変更されていれば、必ずサーバーに取りに行く。</li>
</ul>
</li>
<li>JavaScript や CSS が更新されないとき:

<ul>
<li>タイムスタンプが同じなので、キャッシュを使い続ける。</li>
</ul>
</li>
</ul>


<p>このサイトでも、同じ方法を使うことにしました。ただ、Jekyll で静的にサイト生成しているので、サーバー側で動的にタイムスタンプを埋め込むことはできません。</p>

<p>となれば、タイムスタンプを埋め込んだ状態で Jekyll で HTML を生成すれば万事解決しそうです。</p>

<p>しかし、もう一点、悩みどころがあります。</p>

<h1>GitHub 上に生成結果の HTML をコミットしている</h1>

<p><a href="/ja/blog/2012/09/20/moved-completed/">俺の最強ブログ システムが火を噴くぜ</a> でも書きましたが、このサイトでは Jekyll でビルドした生成結果を GitHub 上に <a href="https://github.com/nitoyon/tech.nitoyon.com/tree/html">html ブランチ</a>としてコミットしています。</p>

<p>その理由は次の通りです。</p>

<ul>
<li> 生成結果の HTML についても差分を管理したい。

<ul>
<li> 何か修正をしたときに変な差分が発生していないかを <code>git diff</code> で確認できる。</li>
<li> 任意の時点のサイトの生成結果を (再ビルドを行うことなく) 知ることができる。</li>
</ul>
</li>
<li> サーバー側では html ブランチに追従するだけでデプロイが完了する。

<ul>
<li> サーバー側にビルド環境を整えなくてよい。</li>
<li> 生成処理はけっこう重いので、(格安レンタルサーバーでは) 時間がかかるプロセスが殺される可能性がある。</li>
</ul>
</li>
</ul>


<p>さて、前述の方法で「キャッシュ問題」に対処するには、JavaScript や CSS を更新するたびに、HTML を書き換えることになります。</p>

<p>たとえば、「JavaScript の更新」をしたとすると、そのスクリプトを利用する「すべての HTML を更新」することになります。このサイトに限っていえば、数百ある過去記事のすべての HTML が一緒に更新されます。</p>

<p>論理的には「JavaScript を 1 回書き換えた」だけなのに、レポジトリ上で数百の HTML ファイルが一緒にコミットされます。HTML の更新履歴に「JavaScript を更新」といった記述が並ぶことになります。</p>

<p>これは美しくありません。</p>

<h1>そこでアクロバティックに解決</h1>

<p>最初は SSI を使おうかとも思ったのですが、「Jekyll の開発サーバー上での表示が困難」「静的生成という大原則が崩れる」ことを理由にパスしました。</p>

<p>いろいろ悩んだ結果、デプロイ時の処理を次のように変更することを思いつきました。</p>

<ol>
<li>html ブランチを <code>git pull</code> する (※いままではこの処理のみだった)。</li>
<li>全部の HTML について、JavaScript・CSS の URL に URL パラメータを付与する。</li>
</ol>


<p>この付与処理を実現するのが、次のスクリプトです。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_scripts/update_js_css_url.rb">update_js_css_url.rb</a></li>
</ul>


<p>だいぶアクロバティックですが、静的生成の大原則を守りつつ、生成結果のレポジトリ上の diff が大きくなりすぎないように工夫してみました。</p>

<p>しばらくはこれでやってみようと思います。</p>
]]></description>
		</item>

		<item>
			<title>俺の最強ブログ システムが火を噴くぜ</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/09/20/moved-completed/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/09/20/moved-completed/</guid>
			<pubDate>Thu, 20 Sep 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>ブログを「はてなダイアリー」から、自分のサーバーに移転しました。</p>

<p>せっかく移転するなら、<strong>2012 年の流行を取り入れた挑戦的なブログにしてみたい！</strong>と思い、構想から半年、ついにこの日を迎えることができました。</p>

<p>せっかくなので、凝ったところを自慢させてください。</p>

<h1>これが俺史上最強のブログ システムだ</h1>

<ul>
<li>ブログ システムとして Jekyll を採用</li>
<li>Jekyll のプラグインを自作 (はてな記法対応、英語ブログとの統合)</li>
<li>履歴管理は GitHub を利用、<code>git push</code> で自動でデプロイ</li>
<li>コメント欄には DISQUS を採用、旧ブログへのコメントはインポート済み</li>
<li>HTML5 マークアップ、CSS3、レスポンシブ Web デザインでのモバイル対応</li>
</ul>


<p>盛りだくさんですね。</p>

<p>詳しく説明していきます。</p>

<h1>ブログ システムとして Jekyll を採用</h1>

<p>最近では WordPress を選ぶのが普通でしょう。WordPress は使ったことありませんが、過去に MovableType で疲弊した苦い経験があります。</p>

<h2>大規模なブログ システムの悪夢</h2>

<p>WordPress や MovableType などの大規模なブログ システムは、管理インターフェースが充実していたり、HTML がしっかり組んであったり、一見カスタマイズしやすいように見えます。しかし、万人の要望にこたえようとするあまり、システムは複雑であり、気軽にはカスタマイズしにくい状態です。</p>

<p>ちょっとしたデザインの修正をしようとしても、元々の HTML の構造を把握するところから始めなければなりません。HTML を書き換えようにも、既存のテンプレートを読んで理解しなければ手をだせません。何らかの動作を変えようとすると、独自プラグインの作り方であったり、場合によっては、本体のソースの海に潜り込んでいく必要が出てきます。</p>

<p>たとえ満足のいくカスタマイズができたとしても、何か別の改造をしようとするとまた同じような手順で<strong>独自のお作法</strong>を調べなきゃいけません。凝って調べている間はそれでもいいのですが、少し間が空くと、また最初から学習しなければなりません。</p>

<p>結局、触らぬ神に祟りなし状態の塩漬けブログになってしまいました。</p>

<p>そんな折、GitHub Pages でホスティングしているブログをいくつか見かけるようになってきました。
一番最初に気づいたのが <a href="http://hozumi.github.com/2012/03/datomic-ja.html">Clojureの作者が作ったデータベースサービス Datomic.com が凄い</a> という記事でした。
この GitHub Pages を裏で支えているのが <strong>Jekyll という「静的サイト生成ツール」</strong>です。</p>

<h2>そこで超絶シンプルな Jekyll です</h2>

<p><a href="https://github.com/mojombo/jekyll">Jekyll</a> は Ruby で書かれていて、ソースは 2,000 行足らずの 50KB ほどと、超絶シンプルです。GitHub Pages での実績があり、Markdown で書ける、プラグインも作れる、シンタックス ハイライトもできる、と意外に盛りだくさんです。</p>

<p><code>jekyll --server --auto</code> として起動しておくと、ブラウザーから確認するための Web サーバーが起動して、テキスト エディターで記事を保存するたびに変換した結果を再生成してくれます。面倒な Web の管理インターフェースは必要ありません。</p>

<p>軽量すぎるので。自分で肉付けしていかなければなりませんが、でっぷり太ったシステムをダイエットさせるよりかは気楽です。</p>

<p>あぁ、なんと、プログラマー フレンドリーなんでしょう。</p>

<p>弱点といえば、毎回すべての記事を生成するので、記事の数が増えてくると HTML 生成に時間がかかってしまう点でしょうか。これを改善するために、生成を高速化したり、変更点のあった記事のみを更新するプラグインを書いています。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/ext/post_yaml_cache.rb">YAML キャッシュ プラグイン</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/ext/site_ext.rb">site_ext プラグイン</a></li>
</ul>


<p>元々のソースがシンプルなので、ちょっとした改善が簡単に試せるのがうれしいところです。</p>

<h2>静的サイトでも何とかなる</h2>

<p>さきほど、Jekyll は「静的サイト生成ツール」だといいました。</p>

<p>「静的サイト」では PHP も Perl も Ruby も動いていません。HTML や CSS をアップロードして終わり、という潔い世界です。</p>

<p>いまどき、CGI なしでサイト運営できるのか、と思う人もいるかもしれません。</p>

<p>「今だからこそ」可能なのです。</p>

<p>CGI が必要になるケースは何があるでしょうか。</p>

<ul>
<li>コメント欄: Facebook や DISQUS などの外部サービスがある。</li>
<li>Twitter や Facebook への対応: 特定の HTML を追加するだけ。</li>
<li>Twitter での評判や関連エントリーの表示: そういう外部サービスがある。</li>
<li>アクセス解析: Google Analytics に任せれば十分。</li>
<li>トラックバック: もはや過去の遺産。 (その気になれば外部サービスがある)</li>
</ul>


<p>ほら、何とかなりますよね。</p>

<p>インターネット初期の静的な HTML が主流の時代から、ブログ システムや CMS を使った動的なサイト生成の時代を経て、いま再び、動的な部分を外部サービスに任せれば静的なコンテンツでいける時代になったのです。</p>

<h1>プラグインを使って Jekyll をカスタマイズ</h1>

<p>軽量な Jekyll さんは、そのまま使うには不完全なところもあります。でも、プラグインの仕組みがあるので大丈夫。</p>

<p>公式 Wiki の <a href="https://github.com/mojombo/jekyll/wiki/Plugins">Plugins</a> には、他の人が作ったプラグインがあります。これらを参考にしつつ、足りない分は自作しました。</p>

<p>作ったプラグインを紹介します。</p>

<h2>はてな記法で記事を書けるように</h2>

<p>せっかく移転するので、過去の記事も引っさげて移転したいと考えました。</p>

<p>「はてなダイアリー」では 500 件以上の記事を書いてきました。500 件の記事を手作業で Markdown に書き換えるのは苦行です。</p>

<p>そこで、「はてな記法」から記事を生成するプラグインを作りました。「はてな記法」の変換処理には、「はてな記法」パーサーの <a href="https://github.com/hotchpotch/hparser/">hparser</a> を使っています。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/converters/hatena.rb">はてな記法コンバーター for Jekyll</a></li>
</ul>


<p>しかし、いざやってみると、hparser には未実装の記法や細かいバグが大量にありました。仕方がないので、本家に沿った出力になるように、hparser にも<a href="https://github.com/hotchpotch/hparser/pull/1">大幅に手を入れました</a>。hparser への修正は GitHub 上で pull リクエストを出して取り込んでもらっています (RubyForge には反映されていないかも)。</p>

<p>あわせて、はてなダイアリーの記事を取り込むために、簡単なスクリプトを書きました。はてなダイアリーの「エクスポート機能」が出力する「はてなの日記データ形式」を入力として。エントリーごとにテキスト ファイルに出力します。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_scripts/convert_hatena_to_jekyll_posts.rb">はてなダイアリー → Jekyll インポート スクリプト convert_hatena_to_jekyll_posts.rb</a></li>
</ul>


<h2>Twitter や Amazon の埋め込み</h2>

<p>ツイートや Amazon の商品埋め込みについては、hparser のレベルではなく、Jekyll プラグインとして実装しました。というのも、はてな記法だけでなく、Markdown で記事を書くときにも、これらの埋め込み機能を使いたかったからです。</p>

<p>各種 API のドキュメントに従いつつ、実装していきました。Ruby のいい練習課題になりました…。API を叩いた結果はキャッシュしているので、初回以外は高速に動作します。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/tags/tweet.rb">tweet プラグイン for Jekyll</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/tags/amazon.rb">Amazon プラグイン for Jekyll</a></li>
</ul>


<h2>複数ブログにも対応!!</h2>

<p><a href="/en/blog/">英語ブログ</a> と同じテンプレートを使いたかったので、複数ブログを実現するプラグインを実装しました。</p>

<p>といっても、Jekyll に元々ある「カテゴリー機能」と「カテゴリーごとに別の URL に出力する機能」を流用しています。記事ごとに設定した「言語名」が、内部的にはカテゴリーとして扱われるようになっています。カテゴリーが使えなくなることを少しためらったのですが、タグ機能もあるのでそちらで十分代用できます。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/ext/post_multilang_by_category.rb">post_multilang_by_category プラグイン</a></li>
</ul>


<p>テンプレートで言語によって違う表示をしたいケースに対応するために、国際化プラグインっぽいものを作りました。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/filters/locale_filter.rb">locale_filter プラグイン</a></li>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_locales/ja.yml">日本語のロケールファイル ja.yml</a></li>
</ul>


<h1>GitHub を積極利用</h1>

<p>先ほどからいくつかのプラグインやスクリプトのリンクを貼っていますが、これらはすべて GitHub で公開しています。公開しているのはプラグインだけでなく、記事のテキスト ファイル、画像、HTML テンプレート、JavaScript など、<strong>サイト生成に必要なものはすべて GitHub で公開</strong>しています。</p>

<p>つまり、GitHub からクローンして、ビルド環境を整えれば、誰でもこのブログを生成できます。</p>

<p>コピー ブログを作られる怖さはありますが、ソースを公開してなくてもコピーする人はコピーするでしょう。それよりも、オープンにすることで、データ紛失の恐怖から解放されます。</p>

<h2>編集履歴を公開するということ</h2>

<p>もう 1 つの副作用として、<strong>記事の編集履歴が丸見えになる</strong>ことが挙げられるでしょう。たとえば、ある記事の編集履歴はこうなります。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/commits/master/_posts/ja/2012-07-31-disqus-comment-import.htn">2012-07-31-disqus-comment-import.htn の編集履歴</a></li>
</ul>


<p>ちょっとした誤字の修正さえも万人に公開されてしまうので、恥ずかしい面はあります。</p>

<p>しかし、メリットも多いと考えています。</p>

<p>ブログの記事をこっそりと書き換えると、不信感を招きます。最悪のケースでは炎上してしまうかもしれません。かといって、追記や補足のたびに「○月○日追記」のように書くと、逆に、初めて見る人は読みにくくなります。2 回目に見る人に誠実になるために、初見の人に不便を強いるのは何か違います。</p>

<p>そこで、GitHub の履歴です。履歴を公開していることを言い訳にすれば、思い切って記事を書き換えやすくなる気がします。将来的には、それぞれの記事ページから「編集履歴」として GitHub のページへのリンクを貼ることも検討しています。</p>

<h2>GitHub から自動デプロイ</h2>

<p>GitHub の <a href="http://help.github.com/post-receive-hooks/">Post-Receive Hooks</a> を使えば、<code>git push</code> したタイミングで特定の URL を叩くことができます。</p>

<ul>
<li><a href="http://d.hatena.ne.jp/viver/20110402/p1">Webサイトをgithubで管理してpush時に自動的に同期する方法 - 古橋貞之の日記 </a></li>
</ul>


<p>この機能を利用して、push 時にサーバーの CGI を叩かれて、<code>git pull</code> で GitHub からデータを取得するようにしました。これだけで、簡単なデプロイ システムのできあがりです。</p>

<p>サーバーは <a href="http://www.sakura.ne.jp/rentalserver/standard/">さくらのレンタルサーバー スタンダード</a> を使っていますが、CGI が使える環境なら、どこでも同じようなことはできます。</p>

<p><a href="https://github.com/nitoyon/tech.nitoyon.com">git レポジトリ</a> 上には 2 つのブランチを作成しています。</p>

<ul>
<li><code>master</code> ブランチ: ソースやプラグインを置く</li>
<li><code>html</code> ブランチ: 生成結果の HTML や CSS を置く (Jekeyll の出力ディレクトリー)</li>
</ul>


<p>先ほどの自作 CGI では、<code>git push</code> 通知を受けとると、<code>html</code> ブランチを pull しでいます。ブランチの構成についてはいろいろ悩んだのですが、次のサイトを参考にしつつ、いまはこの形にしています。</p>

<ul>
<li><a href="http://tokkono.cute.coocan.jp/blog/slow/index.php/programming/github-pages-workflow/">実践GitHub Pages運用のユースケースとワークフローの詳細 | ゆっくりと…</a></li>
</ul>


<h1>コメント欄は DISQUS を利用</h1>

<p>コメント欄として Facebook の利用も検討はしたのですが、過去のコメントをインポートができないこと、コメント欄が殺伐としにくいことを理由に敬遠しました。</p>

<p>そこで目をつけたのが DISQUS です。最近、いろんなところで見かけるようになってきました。有名どころでは <a href="http://jp.techcrunch.com/">TechChrunch Japan</a> が採用しています。</p>

<p>DISQUS はコメントのインポートにも対応しています。しかし、これが意外に苦労して、いまも少し苦労しました。詳しくは <a href="/ja/blog/2012/07/31/disqus-comment-import/">DISQUS へのコメントのインポートが意外に面倒</a> の記事に書いてあるので、こちらをご覧ください。</p>

<h1>HTML5、CSS3、レスポンシブ Web デザイン...</h1>

<p>クライアント サイドの技術でも、最新の流行を取り入れてみました。</p>

<h2>HTML5 マークアップ</h2>

<p>今回、HTML を自由に書けるようになったので、HTML5 マークアップにチャレンジしてみました。<code>&lt;article&gt;</code> などのタグを使っています。</p>

<p>IE8 以下に対応するために <a href="http://code.google.com/p/html5shiv/">html5shiv</a> を使っています。HTML5 的なアウトラインがそれっぽくなるようにも気を使いましたが、完全に自己満足な気がしています。</p>

<h2>Compass で楽々 CSS3</h2>

<p>CSS の生成には Compass を使っています。Compass は Scss にライブラリの皮をかぶせたものになっています。
詳しくは過去記事の <a href="/ja/blog/2012/03/13/newdesign2012/">ブログのデザインを新しくしてみた</a> をご覧ください。</p>

<p>Scss 3.2 を使うことで、Media クエリーにも簡単に対応できるようになりました。興味がある人は <a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/stylesheets/screen.scss">このサイトの screen.scss</a> を見てください。Scss は深入りすればかなり詳しいことができそうですが、あまり大した機能は使っていません。</p>

<p>Jekyll で Compass を使えるように、compass プラグインを作成しました。</p>

<ul>
<li><a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_plugins/converters/compass.rb">compass プラグイン</a></li>
</ul>


<h2>レスポンシブ Web デザインに挑戦</h2>

<p>ちまたに解説が溢れているので特に書くことはありませんが、レスポンシブ Web デザインでスマートフォン対応しました。</p>

<p><code>480px</code> 以下ではスマホ向けのデザインになるようにしています。</p>

<p>もう 1 つの分岐点として <code>45em</code> を設定しています。画面幅が <code>45em</code> 以下なら画面にフィットするようにして、画面幅が <code>45em</code> を超えると固定幅になります。<code>max-width</code> でも対処できるのですが、画面幅に応じて、より細かいカスタマイズができるので、便利だと思いました。</p>

<p>「既存のサイトをデザインそのままでレスポンシブ化するのはよくない」といわれていますが、いまのデザインがスマホ向け表示を意識したものだったので、比較的簡単に対応できました。</p>

<h1>まとめ</h1>

<ul>
<li>移転しました。</li>
<li>新生てっく煮ブログをよろしく。</li>
</ul>

]]></description>
		</item>

		<item>
			<title>暫定で「はてなブログ」に移転した</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/08/27/hatena-blog/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/08/27/hatena-blog/</guid>
			<pubDate>Mon, 27 Aug 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="/ja/blog/2012/06/27/english-blog-renewal/">以前</a>、「はてなブログは使う気ないよー」みたいなことを書いたにも関わらず、はてなブログに引っ越してみました。</p>
<p>これに従って、URL は <a href="http://d.hatena.ne.jp/nitoyon/">http://d.hatena.ne.jp/nitoyon/</a> から <a href="http://tech2.nitoyon.com/">http://tech2.nitoyon.com/</a> に変更になりました。旧 URL へのアクセスはすべて自動的にリダイレクトされます。</p>
<p>(追記) 現在は <a href="http://tech.nitoyon.com">http://tech.nitoyon.com</a> に移転が完了しています</p>
<h1>今回の移転の理由</h1>
<p>将来的に、tech.nitoyon.com にて自前でホスティングしたいという夢は捨てていません。</p>
<p>ただ、その前に、はてなブログの有料プランを介在しておくことで</p>
<ul><li>旧 URL へのアクセスが、独自ドメインの URL にリダイレクトされる</li><li><s>はてなダイアリー上のページランクを新しい URL に引き継ぐことができる</s>、と思っていましたが間違いでした。301 リダイレクトではなく、302 リダイレクトだったため、Google の検索スコアを引き継ぐことはできません。</li><li>はてなブックマーク数も新しいドメインに引き継ぐことができる</li></ul>
<p>というメリットを得られます。</p>
<p>本当なら tech2.nitoyon.com という中途半端なドメインを使わずに、直接 tech.nitoyon.com に移転したかったのですが、tech.nitoyon.com にはブログ以外のコンテンツがいくつか存在しています。その状態で tech.nitoyon.com の DNS の向き先を「はてなブログ」に向けてしまうと、既存のコンテンツが閲覧できなくなって悲しいわけです。移転先のドメインに何もコンテンツが存在していないのなら、直接、新しい URL にリダイレクトさせたと思います。そうすれば、後述する「次の移転」で URL が変わることはないので、よりハッピーだったでしょう。移転先を新しいサブドメイン名にしてもよかったのですが、tech.nitoyon.com というドメインに思い入れがあるので仕方ありません。</p>
<p>もう 1 つ、ひどい方法として、リダイレクトのためだけに「はてなブログ」の有料プランを使う方法も考えられます。移転するリダイレクトの設定だけしておいて、DNS の向き先を「はてなブログ」にしない、という作戦も考えられたのですが、そもそも動くのか分からないです。(はてなブログでリダイレクト先が存在しないなら xxxx.hatenablog.com にリダイレクト先を変えるような実装をしているかもしれない。実際、ドメインの確認ができてない時点で xxxx.hatenablog.com にアクセスしても、独自ドメインに転送してくれない)</p>
<p>何よりも、せっかく有料プランにするので、すこし試してみたい気持ちもありました。</p>
<p>ということで、いったん「はてなブログ」に引っ越すことにしました。</p>
<h1>すぐにやってくる次の移転計画</h1>
<p>このあとの計画は次のようになります。</p>
<ol><li>Google の検索結果が新 URL(tech2.nitoyon.com)になるまでじっと待つ。</li><li>自分のサーバーで tech.nitoyon.com に移転先のコンテンツを準備する。</li><li>自分のサーバーで tech2.nitoyon.com を tech.nitoyon.com にリダイレクトするように設定する。</li><li>tech2.nitoyon.com の DNS の向き先を「はてなブログ」から「自分のサーバー」に移動する。</li><li>d.hatena.ne.jp/nitoyon/ の各記事を「移転先はこちら」といった単純なリンクに書き換える。</li><li>はてなブログのリダイレクト機能を切る。(d.hatena.ne.jp/nitoyon → tech2.nitoyon.com にリダイレクトされなくなる)</li><li>はてなブログの有料プランを解約する。</li></ol>
<p>このようにすることで、</p>
<ul><li>d.hatena.ne.jp/nitoyon/ を開いた人 → 移転先のリンクが表示される。</li><li>tech2.nitoyon.com を開いた人 → 自動的にリダイレクトされる。</li></ul>
<p>という動作になるはずだと信じています。</p>
<h1>はてなブログを使ってみて</h1>
<p>ということで、いまさらながらに「はてなブログ」を使ってみているわけですが、作り直しただけはあって、インターフェースもすっきりしていて使いやすいですね。</p>]]></description>
		</item>

		<item>
			<title>DISQUS へのコメントのインポートが意外に面倒</title>
			<link>http://tech.nitoyon.com/ja/blog/2012/07/31/disqus-comment-import/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2012/07/31/disqus-comment-import/</guid>
			<pubDate>Tue, 31 Jul 2012 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>更新期間が開いてしまったが、ブログの<a href="http://d.hatena.ne.jp/nitoyon/20120627/english_blog_renewal">移転計画</a>を少しずつ進めている。</p>
<p>おおよその過去記事の表示は問題なくなったところであり、もう間もなく移転できるところまで来ているんだけど、コメント欄の移行で手間取っている。</p>
<p>新生ブログのコメント欄には <a href="http://disqus.com/">DISQUS</a> を採用することを検討している。DISQUS はコメント欄の請負サービスとしては最大手だろう。英語圏では CNN や Time、MLB.com などが、日本では <a href="http://jp.techcrunch.com/">TechCrunch JAPAN</a> などが採用している。</p>
<p>アカウント登録して、JavaScript を貼り付けるだけで高機能なコメント欄ができあがるので、気軽で便利なのである。</p>
<h1>インポートの戦略</h1>
<p>ただ、今回は既存のブログがあるので、「JavaScript を貼って、はい、終わり」とはいかない。</p>
<p>過去のコメントをインポートしたいのである。</p>
<p>幸い、DISQUS にはインポート機能がある。WordPress や Blogger、MovableType からのインポートはもちろん、<a href="http://help.disqus.com/customer/portal/articles/472150-custom-xml-import-format">特定の XML フォーマット</a>に従ってコメントを抽出すれば、任意のサービスからのインポートも可能になっている。</p>
<p>なるほど、これを使えば一件落着、と思って手を出してみた。</p>
<br />
<p>今回のインポート元は</p>
<ul><li>日本語ブログ: はてなダイアリー</li><li>英語ブログ: MovableType 3.33</li></ul>
<p>の２つ。</p>
<p>MovableType については DISQUS 側でエクスポートのためのプラグインが用意されている。しかし、よく見てみると MovableType 4.X 用しか用意されていない。3.33 でも動くのかもしれないが、MovableType が面倒になって移転しようとしているので、このためだけにプラグインを入れたり、バージョンアップしたりはしたくない。</p>
<p>一方、はてなダイアリーは MovableType 形式でのエクスポート機能がある。</p>
<p>ということは、両方のブログから MovableType のフォーマットでコメントを吐き出すことはできる。</p>
<p>あとは「MovableType のフォーマット → DISQUS インポート フォーマットへの変換スクリプト」を書けば、両方のブログから DISQUS にインポートできるはずだ。</p>
<h1>インポート 待ち時間の罠</h1>
<p>そんなわけで、せっせとスクリプトを<a href="https://github.com/nitoyon/tech.nitoyon.com/blob/master/_scripts/convert_mt_to_disqus.rb">書いた</a>。ただし、MovableType フォーマットには URL が含まれていないので、手動で XML に追記した。英語ブログには 2 つの記事にしかコメントがついてないので、まずはこれでよい。日本語ブログをインポートするときには、自動化で悩むことにする。</p>
<p>ためしにインポートしてみたら、</p>
<blockquote><p>Imports may take up to 24 hours to complete.</p></blockquote>
<p>と表示される。日本語訳すると「インポート作業は 24 時間かかるかもしれないよ」。</p>
<p>さすがにそんなにかかるわけはないだろう、と思ったものの、実際に 1 日ぐらいかかった。さらに、Importer に遅れが生じていときには、1 日以上待たされることもあった。</p>
<p>アップロードして、結果が分かるのが 1 日後なのである。XML にミスがあって、インポートに失敗した場合には</p>
<ul><li>1 日目: アップロード</li><li>2 日目: うまくいってなかったことが分かる。修正してアップロード</li><li>3 日目: 成功していたことが分かる</li></ul>
<p>と、わずか 1 ミスで 3 日かかってしまうのだ・・・。</p>
<p>ちなみに、自分のインポートの進捗状況は <a href="http://import.disqus.com">http://import.disqus.com</a>、サービス全体 Importer の動作状況は <a href="http://status.disqus.com">http://status.disqus.com</a> で確認できるようになっている。</p>
<p>何度か繰り返していると、運がいいと数分以内にインポートが終了したが、やはり 1 日待たなければならないこともある。Importer の調子次第のようだ。</p>
<h1>コメント フォーマットの CDATA にやられる</h1>
<p>XML の作成については、基本的に <a href="http://help.disqus.com/customer/portal/articles/472150-custom-xml-import-format">DISQUS - Custom XML Import Format</a> に従えばいい。</p>
<p>たとえばコメント本文は</p>
<div class="highlight"><pre>  <span class="c">&lt;!-- comment body; use cdata; html allowed (though will be formatted to DISQUS specs) --&gt;</span>
  <span class="nt">&lt;wp:comment_content&gt;</span><span class="cp">&lt;![CDATA[Hello world]]&gt;</span><span class="nt">&lt;/wp:comment_content&gt;</span>
</pre>
</div>

<p>のような形式で書くことになっている。</p>
<p>仕様を読んだつもりであったのだが「CDATA を使え」を見逃していた。</p>
<p>つまり、本当は CDATA を使って</p>
<div class="highlight"><pre>  <span class="nt">&lt;wp:comment_content&gt;</span><span class="cp">&lt;![CDATA[I&#39;m nitoyon]]&gt;</span><span class="nt">&lt;/wp:comment_content&gt;</span>
</pre>
</div>

<p>と書くべきところを、</p>
<div class="highlight"><pre>  <span class="nt">&lt;wp:comment_content&gt;</span>I<span class="ni">&amp;apos;</span>m nitoyon<span class="nt">&lt;/wp:comment_content&gt;</span>
</pre>
</div>

<p>としていた。</p>
<p>まっとうな XML パーサーを使っていれば、<code>&amp;apos;</code> はシングルクオートになるはずなのだが、インポート結果を見てみると、<code>I&amp;aposm nitoyon</code> となっていた・・・。</p>
<p>インポート後にコメントを編集はできるのだが、コメントの末尾に「(Edited by a moderator)」と表示されてしまう。これでは印象が悪いので、結局最初からやり直すことにした。</p>
<p>やりなおしすると、当然、1 日待たねばならない。</p>
<h1>メールアドレスにやられる</h1>
<p>メールアドレスの設定にも罠があった。仕様によると、</p>
<blockquote><p><code>&lt;wp:comment_author_email&gt;</code> を手動で設定する場合はユーザーごとに一意になるようにしなければならない。そうしないと、同じ名前が表示されてしまう。</p><cite><a href="http://help.disqus.com/customer/portal/articles/472150-custom-xml-import-format">DISQUS - Custom XML Import Format</a></cite></blockquote>
<p>とある。</p>
<p>手動で設定せずに、空欄にしておけばよいと思っていた。英語圏のユーザーに限っていえばその通りだった。</p>
<p>空欄にした場合、ユーザー名から <code>username@wordpress.disqus.net</code> のようなメールアドレスが生成されてインポートされる。ただ、ユーザー名が日本語全角文字のみだったときには、一律に <code>none@wordpress.disqus.net</code> としてインポートされてしまう。</p>
<p>結果として、「日本語のみの名前のコメントは同じ名前が表示されてしまう」現象が発生した。これでは悲しすぎるので、スクリプトを改造して、必ず一意になるようなメールアドレスを割り振って XML を生成するようにした。</p>
<h1>&lt;wp:comment_id&gt; にやられる</h1>
<p>インポートを繰り返す場合は、<code>&lt;wp:comment_id&gt;</code> の指定にも罠があった。</p>
<p>一度インポートしたあとに間違いを発見して、修正して XML をアップロードしても、過去にアップロードしたコメントと <code>&lt;wp:comment_id&gt;</code> が重複していると、コメントが反映されない。</p>
<p>これを回避するために、ID の手前に a とか b とかをつけてアップロードを繰り返した。なんと面倒なことであるか。</p>
<h1>まとめ</h1>
<p>DISQUS のインポートは用意周到に。締め切りのあるケースではやりたくない作業である。</p>]]></description>
		</item>

	</channel>
</rss>