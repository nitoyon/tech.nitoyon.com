<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>てっく煮ブログ</title>
		<link>http://tech.nitoyon.com/ja/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>ja</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Mon, 25 Mar 2013 00:15:47 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/ja/blog/index.xml" rel="self" type="application/rss+xml" />









		<item>
			<title>LiveReloadX 0.2.0 公開！ 除外ファイルを指定可能になったよ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/03/25/livereloadx0-2-0/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/03/25/livereloadx0-2-0/</guid>
			<pubDate>Mon, 25 Mar 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> 0.2.0 を公開した。</p>

<p>新規インストールするなら今まで通り <code>npm install -g livereloadx</code> で、バージョンアップするなら <code>npm update -g livereloadx</code> でどうぞ。</p>

<p>以前のバージョンでは、監視対象のフォルダー配下のファイルが更新されるたびにブラウザーをリロードしていたので、たとえば、git で管理しているフォルダーを監視していると、<code>git commit</code> するたびにブラウザーがリロードされるという悲しい状態だった。</p>

<p>そこで、除外フォルダーやファイルを指定できるようにした。</p>

<p>たとえば、<code>cache</code> フォルダーを監視から除外したいときは</p>
<div class="highlight"><pre><code class="text">$ livereloadx --exclude cache
</code></pre></div>
<p>とすればよい。</p>

<p>また、デフォルトでは html, shtml, css, js, jpg, gif, png, cgi, php など、Web 開発に一通り必要そうな拡張子のみを監視するようにした。たとえば、追加で ini を編集したときにリロードさせたい場合には</p>
<div class="highlight"><pre><code class="text">$ livereloadx --include &quot;*.ini&quot;
</code></pre></div>
<p>とすればよい。いままで通り、すべてのファイルを監視したければ、</p>
<div class="highlight"><pre><code class="text">$ livereloadx --include &quot;*&quot;
</code></pre></div>
<p>とすればよい。</p>

<p>include/exclude の判定ロジックは rsync の真似をしているので自由度はかなり高い。ただ、rsync の include/exclude ルール自体が複雑怪奇なので、それについては別途記事にしようと思う。</p>
]]></description>
		</item>

		<item>
			<title>ファイル編集したら即ブラウザー再読込させる LiveReloadX を作った</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/02/27/livereloadx/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/02/27/livereloadx/</guid>
			<pubDate>Wed, 27 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p><center><img src="http://farm9.staticflickr.com/8100/8509399251_7056f91a11.jpg" width="500" height="294"></center></p>

<p>Web 開発してると、ソースを編集して、ブラウザーをリロードして、という作業の繰り返しになりがちだ。ソースを編集したら、自動でブラウザーをリロードしてくれるような夢のツールがあれば便利そうだ。</p>

<p>この分野では <a href="http://incident57.com/codekit/">CodeKit</a> や <a href="http://livereload.com/">LiveReload</a> などが有名なんだけど、もれなく有料だったり GUI だったりする。そこで、<a href="http://livereload.com/">LiveReload</a> のオープンソースな部分を参考にしつつ、コマンドラインで使える <a href="http://nitoyon.github.com/livereloadx/">LiveReloadX</a> というものを作ってみた。</p>

<p>特長はこんなところ。</p>

<ul>
<li>Node.js を使ってるので Windows/Mac/Linux 問わずに動かせる</li>
<li>開発環境のブラウザーだけでなくスマートフォンのブラウザーもリロードできる</li>
<li>無料</li>
</ul>

<h1>インストール方法</h1>

<p>インストールは超簡単！</p>

<ol>
<li><a href="http://nodejs.org/">Node.js</a> をインストールする。</li>
<li>コマンドラインで <code>npm install -g livereloadx</code> を実行する。</li>
</ol>

<h1>動作原理</h1>

<p><center><img src="http://farm9.staticflickr.com/8099/8509399561_17e6288376.jpg" width="500" height="159"></center></p>

<p>インストールしたら <code>livereloadx</code> コマンドが動くようになる。ただ、それだけではブラウザーはリロードしてくれないので、ちょいと動作原理を説明しておく。</p>

<ol>
<li>コマンドラインで <code>livereloadx path/to/dir</code> を実行すると、LiveReloadX が開始して、次のような処理をする。

<ul>
<li>フォルダー <code>path/to/dir</code> の監視を開始する。</li>
<li>ポート <code>35729</code> で Web サーバーとして動き始める。この Web サーバーは <code>livereload.js</code> を公開しつつ、WebSocket サーバーとしても動く。</li>
</ul></li>
<li>ブラウザーで <code>livereload.js</code> を読み込むと、LiveReloadX サーバーに WebSocket で接続しにいく。</li>
<li><code>path/to/dir</code> 配下のファイルを更新したら、LiveReloadX サーバーはブラウザーに WebSocket で通知を出す。通知を受け取ったブラウザーは再読込する。</li>
</ol>

<p>ということで、ブラウザーに <code>livereload.js</code> を読み込ませる方法が重要になってくる。</p>

<h1>livereload.js の読み込ませ方</h1>

<p>4 通りあるので、好きなやつを選ぶことになる。</p>

<ul>
<li>手動で追加する</li>
<li>ブラウザー拡張をインストールする (PC 版 Safari・Chrome・Firefox のみ).</li>
<li>static モードで実行する</li>
<li>proxy モードで実行する</li>
</ul>

<p>前半の 2 つは LiveReload で提供されてる手段で、後半の 2 つはオリジナルだ。</p>

<h2>手動で追加する</h2>

<p><center><img src="http://farm9.staticflickr.com/8506/8509400159_435002302f.jpg" width="500" height="254"></center></p>

<p>既存の HTML ファイルに次の <code>&lt;script&gt;</code> タグ (JavaScript スニペット) を追加する。それだけ。</p>
<div class="highlight"><pre><code class="html">&lt;script&gt;document.write(&#39;&lt;script src=&quot;http://&#39; + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0] +
&#39;:35729/livereload.js?snipver=2&quot;&gt;&lt;/&#39; + &#39;script&gt;&#39;)&lt;/script&gt;
</code></pre></div>
<p>静的な HTML ファイルで開発してる場合とか、動的 HTML だけどテンプレートを編集するだけで済む場合は、この手順が楽だろう。</p>

<h2>ブラウザー拡張をインストールする</h2>

<p><center><img src="http://farm9.staticflickr.com/8252/8509400245_25dbf28c7f.jpg" width="500" height="260"></center></p>

<p>ソースはいじりたくないよ、という場合は <a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-">How do I install and use the browser extensions? – LiveReload Help &amp; Support</a> からブラウザー拡張を導入するとよい。ただし、対応するブラウザーは PC 版 Safari・Chrome・Firefox のみに限られる。</p>

<p>拡張の LiveReload ツールバーのボタンを押すと、<code>livereload.js</code> が表示中のページに動的に挿入されるようになる。</p>

<h2>static モードで実行する</h2>

<p><center><img src="http://farm9.staticflickr.com/8240/8509400365_6086b6644a.jpg" width="500" height="156"></center></p>

<p>静的なサイトのときには、これが便利かもしれない。<code>-s</code> か <code>--static</code> オプションつきで実行する。</p>
<div class="highlight"><pre><code class="bash">livereloadx -s [-p 35729] [path/to/dir]
</code></pre></div>
<p>static モードでは<strong>静的 Web サーバー</strong>として動作する。</p>

<p>たとえば、<code>http://localhost:35729/foo/</code> にアクセスすると <code>path/to/dir/foo/index.html</code> からファイルを読み取って返してくれる。ついでに、<code>&lt;script&gt;</code> タグを自動で挿入して、ブラウザーが <code>livereload.js</code> を読み込むようにしてくれる。</p>

<h2>proxy モードで実行する</h2>

<p><center><img src="http://farm9.staticflickr.com/8089/8510508898_7c8e065387.jpg" width="500" height="156"></center></p>

<p>HTML をいじりたくないし、ブラウザー拡張も入れたくないし、静的サイトでもないときは、この方法が便利だろう。<code>-y http://example.com/</code> か <code>--proxy http://example.com/</code> オプションをつけて実行する。</p>
<div class="highlight"><pre><code class="text">$ livereloadx -y http://example.com/ [-p 35729] [-l] [path/to/dir]
</code></pre></div>
<p>proxy モードでは<strong>リバース プロキシー</strong>として動作する。</p>

<p>たとえば、<code>http://localhost:35729/foo/</code> にアクセスすると、裏側で <code>http://example.com/foo/</code> からデータを取ってきてクライアントに返す。ついでに、<code>&lt;script&gt;</code> タグを自動で挿入して、ブラウザーが <code>livereload.js</code> を読み込むようにしてくれる。</p>

<p>さらに、<code>-l</code> か <code>--prefer-local</code> フラグをつけて起動すると、最初にローカルのファイルがあるか確認して、あればそっちを返すようになる。稼働中の本番環境のうち、一部の JavaScript とか CSS だけを手元に持ってきて編集しながら検証できて便利だ。</p>

<h1>まとめ</h1>

<p>LiveReloadX を紹介した。Node.js の勉強がてら作っていたのだけど、なかなか便利なツールになったのではないかと思う。</p>

<p>ソースは <a href="https://github.com/nitoyon/livereloadx">nitoyon/livereloadx - GitHub</a>  にあるので、Star や Pull Request してもらえると、とてもうれしい。</p>
]]></description>
		</item>

		<item>
			<title>Node.js＋CoffeeScript でソースマップを使ってデバッグを楽にする方法</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/02/19/node-source-map/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/02/19/node-source-map/</guid>
			<pubDate>Tue, 19 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>以前、<a href="/ja/blog/2013/01/29/jquery-source-map/">jQuery 1.9 のソースマップ対応で圧縮版でもデバッグが簡単になった話</a> を書いたけど、Node.js でソースマップする方法を紹介する。</p>

<p>何がうれしいかというと、Node.js で CoffeeScript や TypeScript、JSX なんかを使ったときに、例外に含まれるスタックトレースに変換前の位置を表示できる。</p>

<p>やり方は簡単。<a href="https://github.com/evanw/node-source-map-support/">source-map-support</a> というモジュールを <code>require()</code> するだけ。</p>

<h1>ためしに使ってみた</h1>

<p>GitHub に動かし方が書いてあるので、その通りにやってみる。</p>

<p>こんな感じの <code>demo.coffee</code> があったとする。</p>
<div class="highlight"><pre><code class="coffeescript">require &#39;source-map-support&#39;
foo = -&gt;
  bar = -&gt; throw new Error &#39;this is a demo&#39;
  bar()
foo()
</code></pre></div>
<p><code>npm install source-map-support</code> で source-map-support モジュールをインストールしておく。</p>

<p>生の CoffeeScript がソースマップに対応してないので、CoffeeScriptRedux を使って JavaScript に変換する。</p>
<div class="highlight"><pre><code class="bash">$ CoffeeScriptRedux/bin/coffee --js -i demo.coffee &gt; demo.js
$ echo &#39;//@ sourceMappingURL=demo.js.map&#39; &gt;&gt; demo.js
$ CoffeeScriptRedux/bin/coffee --source-map -i demo.coffee &gt; demo.js.map
</code></pre></div>
<p>あとは普通に実行すれば、スタックトレースには coffee ファイルの位置が出てくる。</p>
<div class="highlight"><pre><code class="bash">$ node demo.js

demo.coffee:4
  bar = -&gt; throw new Error &#39;this is a demo&#39;
                  ^
Error: this is a demo
    at bar (demo.coffee:4:19)
    at foo (demo.coffee:5:3)
    at Object.&lt;anonymous&gt; (demo.coffee:6:3)
    at Object.&lt;anonymous&gt; (demo.coffee:6:6)
    at Module._compile (module.js:449:26)
                 :
</code></pre></div>
<p><code>bar (demo.coffee:4:19)</code> のところにご注目。</p>

<p>本当だったら、ここがコンパイル後の demo.js 上の位置になってるはずなんだけど、source-map-support モジュールのおかげで、コンパイル前の位置が表示されている。</p>

<p>ここでは示してないけど、<code>Error</code> を <code>catch</code> したときの <code>error.stack</code> も coffee ファイルの場所になる。</p>

<p>CoffeeScript だけじゃなく、TypeScript や JSX もソースマップには対応しているし、圧縮やファイル結合したきにもソースマップさえ吐いておけば、このように変換前の位置情報を出力してくれるようになるので、便利便利である。</p>

<h1>仕組み</h1>

<p>動作原理が気になったので <a href="https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js">source-map-support.js</a> のソースをざっと読んでみた。</p>

<p>一番の肝は <code>Error.prepareStackTrace()</code> を定義して、スタックトレースを書き換えているところ。どうやら V8 エンジンの <a href="http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi">Stack Trace API</a> というものがあるようだ。</p>

<p>また、未処理の例外のときに例外が発生した位置のソースを表示するために、<code>process.on(&#39;uncaughtException&#39;, ...)</code> でがんばって処理している。</p>

<p>ソースマップの解析には <a href="https://github.com/mozilla/source-map">Mozilla の source-map モジュール</a> を使っているようだ。</p>

<h1>まとめ</h1>

<p>Node.js でもソースマップが使えるよ。</p>

<p>(参考記事) <a href="http://badassjs.com/post/42588937391/node-js-source-map-support-for-better-compiled">Node.js Source Map Support for Better Compiled JavaScript Debugging - Badass JavaScript</a></p>
]]></description>
		</item>

		<item>
			<title>これがスマートフォン向けサイトを作るときの viewport 設定３パターンだ</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/02/15/viewport/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/02/15/viewport/</guid>
			<pubDate>Fri, 15 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>スマートフォン向けの Web サイトを作るとき、viewport の設定次第で使い勝手が大幅に変わる。</p>

<p>最近はレスポンシブ Web デザインが流行してるけども、その大前提として viewport の設定パターンを抑えておくのは重要だろう。</p>

<p>この記事では、viewport の設定によって、見た目・使い勝手がどう変わるかを解説する。</p>

<h1>パターン1: 何も考えずに HTML を書く</h1>

<p>まずは、viewport を指定せずに、単純な HTML をスマートフォンで表示してみる。</p>
<div class="highlight"><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;/images/logo-ja.png&quot;&gt;
&lt;p&gt;色んな素材がごった煮になった様子をお椀で表現しています。
湯気が&lt;strong&gt;「てっく」&lt;/strong&gt;に見えるのが隠し味になっています。
「てっく煮」の右肩の「+4」 を「と、よん」と読むことで、
ドメイン名の tech.nitoyon.com と等しくなります。&lt;/p&gt;
&lt;/body&gt;
</code></pre></div>
<h2>表示結果</h2>

<p>iPhone 3GS (iOS 5.1.1) で表示してみた (<a href="./no-viewport.html">デモ ページ</a>)。</p>

<p><center><img src="http://farm9.staticflickr.com/8225/8472828815_ce69aec918.jpg" width="500" height="306"></center></p>

<p>スマホ対応していないサイトを表示した状態だ。</p>

<p>スマホートフォンは PC 向けのサイトを表示するときには、「横幅 980px 向けにデザインされている」という前提で描画する。結果として、文字が小さくなる。</p>

<p>どれぐらい小さくなるか、iPhone を例に調べてみよう。iPhone のそれぞれの世代で、横幅 980px のページがどれぐらい縮小されて表示されるかを計算してみた。</p>

<table><thead>
<tr>
<th>世代</th>
<th>解像度</th>
<th align="right">縦向き</th>
<th align="right">横向き</th>
</tr>
</thead><tbody>
<tr>
<td>iPhone 1～3</td>
<td>320px × 480px</td>
<td align="right">32.7%</td>
<td align="right">49.0%</td>
</tr>
<tr>
<td>iPhone 4</td>
<td>640px × 960px</td>
<td align="right">65.3%</td>
<td align="right">98.0%</td>
</tr>
<tr>
<td>iPhone 5</td>
<td>640px × 1,136px</td>
<td align="right">65.3%</td>
<td align="right">116.0%</td>
</tr>
</tbody></table>

<p>iPhone 4 以降の縦向き (Portrate mode) で 980px の PC 向けサイトは 2/3 に縮小して表示される。Retina ディスプレイで 2/3 のなので、文字はかなり小さくなる。ピンチ操作で拡大しないと読めない人も多いだろう。</p>

<h2>採用例</h2>

<p>このパターンでもデザインを工夫すれば、スマートフォンやタブレットでも見やすくなる。その代表格が Apple である。</p>

<p>ここでは詳しく触れないが、<a href="http://www.pxt.jp/ja/diary/article/257/index.html">pxt | 考察：Appleはスマホサイトを作らない。</a> に分かりやすく書いてあるので、興味がある人は読んでみるとよいだろう。</p>

<h1>パターン2: viewport でデバイスの横幅を指定する</h1>

<p>「スマホ向けにデザインしているよ」と主張するには <code>&lt;head&gt;</code> タグの中に <code>viewport</code> を 1 行追加すればよい。</p>
<div class="highlight"><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
</code></pre></div>
<p><code>width=device-width</code> というのは「デバイスの横幅で描画してください」という意味である。</p>

<p>一昔前は iPhone 前提で <code>width=320px</code> と指定すれば十分だったが、解像度がまちまちな Android やタブレット端末が登場したため、<code>width=device-width</code> と指定するのが新常識になった。</p>

<h2>表示結果</h2>

<p>表示するとこうなる (<a href="./scalable-viewport.html">デモ ページ</a>)。</p>

<p><center><img src="http://farm9.staticflickr.com/8101/8473918432_eddb076e37.jpg" width="500" height="306"></center></p>

<p>横向きにしたときには、縦向きのときの画面を引き伸ばして表示しようとするので、かなり拡大された印象になる (iPhone 4 までで 1.5 倍、iPhone 5 では 1.7 倍)。</p>

<p>字が大きくなって読みやすくなるが、画面内の情報量が少なくなる。</p>

<h2>採用例</h2>

<p>あまり見たことがないが、たとえば、<a href="http://b.hatena.ne.jp/touch">はてなブックマーク スマートフォン版</a> のソースを見ると、</p>
<div class="highlight"><pre><code class="html">&lt;meta content=&quot;width=320, minimum-scale=0.5&quot; name=&quot;viewport&quot; /&gt;
</code></pre></div>
<p>となっている。<code>320px</code> とあるので、旧世代の指定のままだ。現実問題として、Nexus 7 で閲覧すると <code>320px</code> だと信じて描画するので、フォントがでかすぎて見づらい。</p>

<h1>パターン3: 回転してもサイズを変えたくないケース</h1>

<p>スマートフォンのネイティブ アプリの動作をみていると、横向き (Landscape mode) にしたときには１行に表示する文字の数が増えるものが多い。</p>

<p>例えば、iPhone 3GS 標準のメモ アプリがそうである。</p>

<p><center><img src="http://farm9.staticflickr.com/8524/8472918769_f183e967df.jpg" width="500" height="306"></center></p>

<p>Web においても同様に「横向きのときは一行の文字数を増やしたり、追加の情報を表示したりしたい」という欲求がでてくる。</p>

<p>そのような場合は、<code>viewport</code> を次のように書きなおせばよい。</p>
<div class="highlight"><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;
</code></pre></div>
<p>あわせて CSS に次のように指定しておく。</p>
<div class="highlight"><pre><code class="css">body {
  -webkit-text-size-adjust: 100%;
}
</code></pre></div>
<p>(理由は <a href="/ja/blog/2013/02/14/text-size-adjust/">-webkit-text-size-adjust: none を絶対に設定してはいけない理由</a> を参照)</p>

<h2>表示結果</h2>

<p>横方向のときには次のようになる (<a href="./unscalable-viewport.html">デモ ページ</a>)。</p>

<p><center><img src="http://farm9.staticflickr.com/8523/8473918482_552250ded9.jpg" width="500" height="306"></center></p>

<p>メモ アプリの利用イメージに近くなった。</p>

<p>ただし、この指定にしてしまうと、<strong>ピンチによる拡大・縮小ができない</strong>という大きな弱点がある。</p>

<h2>採用例</h2>

<p>数多くの大手サイトがこの方式を採用している。Google も Yahoo! Japan も twitter も facebook も全部これである。</p>

<p>「ピンチできない」という大きな欠点はあるものの、端末の縦横方向を変えたときに画面内の情報量を減らしたくないないので、このパターンを採用せざるをえないのだろう。</p>

<p>向きを変えたときに横幅が変わりつつピンチも使えるような手段が提供されるのが理想なのだが、現在のところ、そのような指定をする方法はない。</p>

<h2>補足</h2>

<p><code>viewport</code> で指定してるのは長ったらしい値は、次のようになっている。</p>
<div class="highlight"><pre><code class="text">width         = device-width
initial-scale = 1.0
minimum-scale = 1.0
maximum-scale = 1.0
user-scalable = no
</code></pre></div>
<p>この設定により、iPhone と Android でページの表示倍率が <code>1.0</code> 固定にして、ページのピンチができないようにしている。</p>

<p>その結果、ページの表示倍率が変わる余地をなくしている。表示倍率が変えられない状態になってはじめて、WebKit は仕方なくページの横幅を変えてくれるようだ。</p>

<h1>パターン4: 拡大・縮小は認めたいケース</h1>

<p>記事を公開したあと、コメント欄で教えてもらったのがこのパターン。</p>
<div class="highlight"><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
</code></pre></div>
<p>と設定することで、「ピンチは可能」かつ「横向きにしたときに 1 行の情報量が増える」を実現できる。</p>

<p>文字のサイズを固定化したいなら、パターン 3 と同じように CSS に次のように指定しておく。</p>
<div class="highlight"><pre><code class="css">body {
  -webkit-text-size-adjust: 100%;
}
</code></pre></div>
<p>(理由は <a href="/ja/blog/2013/02/14/text-size-adjust/">-webkit-text-size-adjust: none を絶対に設定してはいけない理由</a> を参照)</p>

<h2>採用例</h2>

<p><a href="http://twitter.github.com/bootstrap/">Bootstrap</a> のサイトはこのパターンだし、<a href="http://learn.jquery.com/jquery-mobile/getting-started/">jQuery mobile の Getting Started</a> でもこのパターンが推奨されている。</p>

<p>方向を変えたときに、表示倍率が変わってしまうのが少し気になったが、利用者が自由に拡大・縮小できるので自由度が高い。。</p>

<h1>まとめ</h1>

<p>以上の内容を表でまとめる。</p>

<table><thead>
<tr>
<th align="center">番号</th>
<th>選ぶポイント</th>
<th>弱点</th>
<th>例</th>
</tr>
</thead><tbody>
<tr>
<td align="center">1</td>
<td>PC 向けのサイトをスマホで見ても、十分に見やすいとき。</td>
<td>初期状態の文字が小さい。</td>
<td>Apple</td>
</tr>
<tr>
<td align="center">2</td>
<td>縦向き・横向きでレイアウトを変えたくないとき。</td>
<td>横向きにしたときに極端に拡大される。</td>
<td>△</td>
</tr>
<tr>
<td align="center">3</td>
<td>サイトの使い勝手をアプリっぽくしたいとき。</td>
<td>ピンチで拡大・縮小できない。</td>
<td>◎</td>
</tr>
<tr>
<td align="center">4</td>
<td>縦向き・横向きに対応しつつピンチも許可したいとき。</td>
<td>向きを変えると表示倍率が変動する。</td>
<td>○</td>
</tr>
</tbody></table>

<p>このブログでも、ピンチできないのは不便だけど、結局、他の大手サイトと同じく 3 番目を採用した。</p>
]]></description>
		</item>

		<item>
			<title>-webkit-text-size-adjust: none を絶対に設定してはいけない理由</title>
			<link>http://tech.nitoyon.com/ja/blog/2013/02/14/text-size-adjust/</link>
			<guid>http://tech.nitoyon.com/ja/blog/2013/02/14/text-size-adjust/</guid>
			<pubDate>Thu, 14 Feb 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>PC 版の Google Chrome や Safari で見たときにユーザビリティーが落ちるから。</p>

<p>以上。</p>

<p>で終わってしまうと記事にならないので、ちゃんと説明しておく。</p>

<h1>そもそも -webkit-text-size-adjust とは何か</h1>

<p>iPhone や Android のブラウザーは、縦向き (Portrate mode) と横向き (Landscape mode) の文字サイズを自動調整する機能がある。</p>

<p>これを制御するのが CSS の <code>-webkit-text-size-adjust</code> である。</p>

<h2>文字サイズ自動調整の具体例</h2>

<p>次のような HTML をスマートフォンで表示してみる。</p>
<div class="highlight"><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;
&lt;/head&gt;
&lt;body background=&quot;layout_grid.png&quot;&gt;
&lt;img src=&quot;/images/logo-ja.png&quot;&gt;
&lt;p&gt;色んな素材がごった煮になった様子をお椀で表現しています。
湯気が&lt;strong&gt;「てっく」&lt;/strong&gt;に見えるのが隠し味になっています。
「てっく煮」の右肩の「+4」 を「と、よん」と読むことで、
ドメイン名の tech.nitoyon.com と等しくなります。&lt;/p&gt;
&lt;/body&gt;
</code></pre></div>
<p>スマホ対応であることを主張するために viewport のおまじないを <code>&lt;meta&gt;</code> タグに書いている。それ以外はありきたりな単純な HTMLである。</p>

<p>このページを iPhone 3GS (iOS 5.1.1) で表示するとこうなった (<a href="./adjust.html">デモ ページ</a>)。</p>

<p><center><img src="http://farm9.staticflickr.com/8088/8467618983_5e6b9d2307.jpg" width="500" height="306"></center></p>

<p>横向きにしたときに画像のサイズはそのままで、<strong>文字のサイズだけが大きくなっている</strong>。</p>

<p>おそらく 1 行あたりの文字数が増えすぎると読みにくくなるから、という配慮なんだろうけど、余計なお世話なのでオフにしたくなる。</p>

<h2>自動調整をオフにしたい</h2>

<p>この自動調整をしているのが <code>-webkit-text-size-adjust</code> プロパティー。</p>

<p>デフォルト値は <code>auto</code> になっていて、<code>100%</code> や <code>none</code> にすると自動調整をオフにできる。</p>
<div class="highlight"><pre><code class="css">body {
  -webkit-text-size-adjust: 100%;
}
</code></pre></div>
<p>さきほどの例でも、文字のサイズが変わらなくなった (<a href="./no-adjust.html">デモ ページ</a>)。</p>

<p><center><img src="http://farm9.staticflickr.com/8515/8471101882_a792b39c70.jpg" width="500" height="306"></center></p>

<h2>none を設定してはいけない</h2>

<p>ここで重要なのが、<code>-webkit-text-size-adjust</code> は <strong><code>none</code> に設定すると副作用があるので <code>100%</code> を設定すべき</strong>という点だ。</p>

<p>検索してみると層々たるサイトで「<code>none</code> に設定しましょう」という記述があるんだけど、危険なので注意が必要だ。</p>

<p>危険な情報を載せているサイトの一例:</p>

<ul>
<li><a href="http://coliss.com/articles/build-websites/operation/css/css-tutorial-media-queries-by-webdesignerwall.html">[CSS]スマフォ対応サイトのためにMedia Queriesをしっかり身につけるチュートリアル | コリス</a></li>
<li><a href="http://www.atmarkit.co.jp/fsmart/articles/iphone/04.html">iPhone向けWebアプリを作ろう（4/4） － ＠IT</a></li>
<li><a href="http://zero.css-happylife.com/property/-webkit-text-size-adjust.shtml">-webkit-text-size-adjust｜プロパティ｜CSS HappyLife ZERO</a></li>
<li><a href="http://webdesignrecipes.com/web-design-for-mobile-with-css3-media-queries/">CSS3 Media Queries を使って、Webサイトをスマートフォンに対応させるときの注意書き - Webデザインレシピ</a></li>
</ul>

<h1>none が絶対にダメな理由</h1>

<p><code>-webkit-text-size-adjust: none</code> を指定してしまうと PC 版の Google Chrome や Safari でページの拡大/縮小機能に支障がでる。</p>

<p>たとえば、<a href="http://www.itmedia.co.jp/">ITmedia</a> には <code>none</code> が指定されてしまっているので悪い例として取り上げさせてもらう。Google Chrome (バージョン 24) にて 100% と 200% で ITmedia のトップページを表示するとこうなる。</p>

<p><center><img src="http://farm9.staticflickr.com/8515/8467619207_37643f6d2a.jpg" width="500" height="305"></center></p>

<p>画像や文字の位置は拡大されているのに<strong>文字が拡大されていない</strong>。目が悪い人や高解像度ディスプレイを使っている人にとっては、読みやすくするために拡大しても文字が小さいままなので、たいそう不便である。</p>

<p>ためしに、Google Chrome の開発者コンソールで <code>&lt;body&gt;</code> タグの <code>-webkit-text-size-adjust</code> プロパティーを <code>none</code> から <code>100%</code> に書き換えてみると、期待した通りの表示になる。</p>

<p><center><img src="http://farm9.staticflickr.com/8515/8468714646_3fc95ee0ff.jpg" width="500" height="305"></center></p>

<p>これが、<code>none</code> がダメで、<code>100%</code> を推奨している理由である。</p>

<p>昨今のレスポンシブ Web デザインの流行もあり、PC 向けサイトに <code>-webkit-text-size-adjust</code> が指定されることも増えてきた。もし、<code>none</code> を指定しちゃうと、目が悪い人や高解像度ディスプレイを使っている人がページを拡大できなくなっちゃう。これは重大なアクセシビリティーの欠陥である。</p>

<h2>none で拡大されないのは WebKit のバグ</h2>

<p>Mozilla の資料 <a href="https://developer.mozilla.org/en-US/docs/CSS/text-size-adjust">text-size-adjust - CSS | MDN</a> には、この挙動は WebKit のバグだと書いてある (日本語訳は私によるもの)。</p>

<blockquote>
<p>WebKit ベースの PC 版ブラウザーにはバグがある。<code>-webkit-text-size-adjust</code> に <code>none</code> を設定していると、PC 版の Chrome や Safari は、このプロパティーを無視すべきなのに、ページの拡大/縮小を妨害する動作をする。</p>

<blockquote>
<p>There is a bug in Webkit-based desktop browsers. If <code>-webkit-text-size-adjust</code> is explicitely set to <code>none</code>, Webkit-based desktop browsers, like Chrome or Safari, instead of ignoring the property, will prevent the user to zoom in or out the Web page.</p>
</blockquote>
</blockquote>

<p>このバグは WebKit Bugzilla に <a href="https://bugs.webkit.org/show_bug.cgi?id=56543">Bug 56543 - CSS property &quot;-webkit-text-size-adjust&quot; means different things in Safari and iOS</a> として バグ登録されている。パッチも提供されている。</p>

<p>しかし、現在のところ解決には至っていない。</p>

<h1>このバグへの対処方法</h1>

<h2>理想</h2>

<p>WebKit のバグが修正されるのが一番いい。</p>

<h2>現実</h2>

<p>しかし、修正される気配はないし、たとえ修正されたとしても、一定期間は古いブラウザーを使う人がいる。</p>

<p>だから、繰り返しになるが、現時点では</p>
<div class="highlight"><pre><code class="css">body {
  -webkit-text-size-adjust: none;
}
</code></pre></div>
<p>ではなく</p>
<div class="highlight"><pre><code class="css">body {
  -webkit-text-size-adjust: 100%;
}
</code></pre></div>
<p>を設定すべきだ。</p>

<p>スマホ専用サイトであれば <code>-webkit-text-size-adjust: none</code> を設定しても困る人はいないのだけど、別の人がコピペで PC サイトに流用する可能性もあるだろうから、<code>-webkit-text-size-adjust: 100%</code> を習慣づけておいて損はないだろう。</p>

<h2>利用者側の対策</h2>

<p>さきほど、ITmedia の例を紹介したが、よく使うサイトでこの CSS が指定されていると不便だ。</p>

<p>たとえば、はてなブックマークの新しいトップページは、公開当初、<code>none</code> を指定していた。普段から拡大して表示していた自分は困ってしまったのだが、中の人が <a href="http://kudakurage.hatenadiary.com/entry/2013/02/08/135725">タイムリーな記事</a> で <code>none</code> を推奨していたので、「<code>100%</code> にすべきだよ」とコメントしてみた。すると、数時間後には、はてなブックマークの CSS も治っていた。すばやい対応でありがたい。</p>

<p>とはいえ、サイトごとにいちいち連絡するのも面倒なので、ユーザースタイルシートを書くなり、対策用のブラウザー拡張を入れるなりするのが現実的だろう。自分の場合は Google Chrome に <a href="https://chrome.google.com/webstore/detail/webkit-text-size-adjust-r/jgfjnnljbpgajihjcajeiabjomhmjhec">Webkit-Text-Size-Adjust Remover</a> を入れたら快適になった。ITmedia も快適に拡大できるようになった。</p>

<h1>３行でまとめる</h1>

<p>長くなったが、強引に３行でまとめる。</p>

<ul>
<li>WebKit はこのバグを治してほしい。</li>
<li>対症療法にはなるけど <code>-webkit-text-size-adjust: none</code> はダメ。<code>100%</code> と書け。</li>
<li>バグを回避するための <a href="https://chrome.google.com/webstore/detail/webkit-text-size-adjust-r/jgfjnnljbpgajihjcajeiabjomhmjhec">Webkit-Text-Size-Adjust Remover</a> のような拡張もあるので、拡大できないサイトがあって困ってるなら入れるとよい。</li>
</ul>
]]></description>
		</item>

	</channel>
</rss>