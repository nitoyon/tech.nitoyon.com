<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>TECH-NI Blog</title>
		<link>http://tech.nitoyon.com/en/blog/index.xml</link>
		<description>All Technology is Boiled in This Site.</description>
		<language>en</language>
		<copyright>Copyright nitoyon.</copyright>
		<lastBuildDate>Thu, 10 Oct 2013 00:23:58 +0000</lastBuildDate>
		<docs>http://blogs.law.harvard.edu/tech/rss</docs>
		<atom:link href="http://tech.nitoyon.com/en/blog/index.xml" rel="self" type="application/rss+xml" />





		<item>
			<title>When grunt-contrib-watch uses too much CPU, try grunt-este-watch</title>
			<link>http://tech.nitoyon.com/en/blog/2013/10/10/grunt-watch-slow/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/10/10/grunt-watch-slow/</guid>
			<pubDate>Thu, 10 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>I used <a href="http://gruntjs.com/">Grunt</a> and <a href="https://github.com/gruntjs/grunt-contrib-watch"><code>grunt-contrib-watch</code></a> in my project. </p>

<p>Although <code>grunt-contrib-watch</code> works fine when the number of files is small, but as it grows up, <code>grunt-contrib-watch</code> starts using too much CPU. For example, when <code>grunt-contrib-watch</code> is watching about 1,000 files, node always uses 10% of my CPU.</p>

<p>This is known issue. Look at the <a href="https://github.com/gruntjs/grunt-contrib-watch/#why-is-the-watch-devouring-all-my-memorycpu">FAQ</a>:</p>

<blockquote>
<p>Another reason if you&#39;re watching a large number of files could be the low default <code>interval</code>. Try increasing with <code>options: { interval: 5007 }</code>. Please see issues <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/35">#35</a> and <a href="https://github.com/gruntjs/grunt-contrib-watch/issues/145">#145</a> for more information.</p>
</blockquote>

<h1>What causes high CPU usage?</h1>

<p><code>grunt-contrib-watch</code> uses <a href="https://github.com/shama/gaze"><code>gaze</code></a> module to watch files.</p>

<p>This module uses not only <code>fs.watch()</code> (native API) but also <code>fs.watchFile()</code> which periodically executes <code>fs.statSync()</code> (read <a href="/en/blog/2013/10/02/node-watch-impl/">Difference between fs.watch() and fs.watchFile()</a> for details).</p>

<p>Why does <code>gaze</code> use <code>fs.watchFile()</code>? <a href="https://github.com/paulmillr/chokidar">chokidar/README.md</a> says <code>fs.watch()</code> had many problems.</p>

<blockquote>
<p>Node.js <code>fs.watch</code>:</p>

<ul>
<li>Doesn&#39;t report filenames on mac.</li>
<li>Doesn&#39;t report events at all when using editors like TextMate2 on mac.</li>
<li>Sometimes report events twice.</li>
<li>Has only one non-useful event: <code>rename</code>.</li>
<li>Has <a href="https://github.com/joyent/node/search?q=fs.watch&amp;type=Issues">a lot of other issues</a></li>
</ul>
</blockquote>

<h1>How do I avoid it?</h1>

<p>Use <a href="https://github.com/steida/grunt-este-watch/"><code>grunt-este-watch</code></a> instead of <a href="https://github.com/gruntjs/grunt-contrib-watch"><code>grunt-contrib-watch</code></a>.</p>

<p>Let&#39;s read <a href="https://github.com/steida/grunt-este-watch/blob/master/README.md"><code>grunt-este-watch/README.md</code></a>.</p>

<blockquote>
<p><em>What&#39;s wrong with official grunt-contrib-watch?</em></p>

<p>It&#39;s slow and buggy, because it uses combination fs.fileWatch and fs.watch, for
historical reason. From Node 0.9.2+, fs.watch is ok.</p>

<p><a href="http://github.com/steida/este">github.com/steida/este</a> Needs maximum performance and
stability, so that&#39;s why I had to create yet another Node.js file watcher.
This watcher is continuously tested on Mac, Linux, Win platforms.</p>
</blockquote>

<p>I&#39;m using <code>grunt-este-watch</code> now. It uses no CPU when watching. Nice!</p>

<h2>Example</h2>

<p>Here is my <a href="https://github.com/nitoyon/tech.nitoyon.com/blob/b1fd0f12a6318b200390d8a2934d5cb66e46d454/Gruntfile.js"><code>Gruntfile.js</code></a>:</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll_build: {
        command: &#39;jekyll build&#39;
      },
      // snip
    },
    // snip
    esteWatch: {
      options: {
        dirs: [&#39;./&#39;, &#39;_posts/*/&#39;, &#39;_layouts&#39;, &#39;_includes&#39;,
               &#39;javascript/**/&#39;, &#39;apollo/tutorial&#39;,
               &#39;_plugins/**/&#39;, &#39;stylesheets&#39;, &#39;javascripts&#39;],
        livereload: {
          enabled: false
        }
      },
      &#39;*&#39;: function(filepath) { return &#39;shell:jekyll_build&#39; }
    }
  });
</code></pre></div>
<p><code>grunt-este-watch</code>&#39;s configuration is quite different from <code>grunt-contrib-watch</code>&#39;s.</p>

<p><code>grunt-este-watch</code> requires directory list to watch. When any file under watched directory is modified, callback function is called.</p>

<p>My callback function returns <code>&#39;shell:jekyll_build&#39;</code>, so <code>grunt</code> executes <code>shell:jekyll_build</code> when watched files are modified. We can check <code>filepath</code> argument to determine the tasks returned.</p>

<p><code>&#39;*&#39;</code> means all extensions. We can register callback to specified extension. There is a good example on <a href="https://github.com/steida/grunt-este-watch/blob/master/README.md">grunt-este-watch/README.md</a>.</p>
<div class="highlight"><pre><code class="javascript language-javascript" data-lang="javascript">    coffee: function(filepath) {
      var files = [{
        expand: true,
        src: filepath,
        ext: &#39;.js&#39;
      }];
      grunt.config([&#39;coffee&#39;, &#39;app&#39;, &#39;files&#39;], files);
      grunt.config([&#39;coffee2closure&#39;, &#39;app&#39;, &#39;files&#39;], files);
      return [&#39;coffee:app&#39;, &#39;coffee2closure:app&#39;];
    },
    // snip
    css: function(filepath) {
      if (grunt.option(&#39;stage&#39;)) {
        return &#39;cssmin:app&#39;;
      }
    }
</code></pre></div>
<p>Enjoy!</p>
]]></description>
		</item>

		<item>
			<title>Difference between fs.watch() and fs.watchFile()</title>
			<link>http://tech.nitoyon.com/en/blog/2013/10/02/node-watch-impl/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/10/02/node-watch-impl/</guid>
			<pubDate>Wed, 02 Oct 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>Node.js has two functions for file watching. <code>fs.watch()</code> and <code>fs.watchFile()</code>.</p>

<p>These functions look similar. What&#39;s the difference?</p>

<h1>Official Document</h1>

<p>According to official <a href="http://nodejs.org/docs/v0.8.0/api/fs.html#fs_fs_watchfile_filename_options_listener">document (v0.8.0)</a>,</p>

<blockquote>
<h2>fs.watchFile(filename, [options], listener)</h2>

<p>Stability: 2 - Unstable.  Use fs.watch instead, if available.</p>

<p>Watch for changes on <code>filename</code>.</p>

<h2>fs.watch(filename, [options], [listener])</h2>

<p>Stability: 2 - Unstable.  Not available on all platforms.</p>

<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a directory.</p>
</blockquote>

<p>we can say</p>

<ul>
<li><code>fs.watch()</code> is recommended.</li>
<li><code>fs.watch()</code> is not available on all platforms.</li>
<li><code>fs.watch()</code> watches a file or a directory. <code>fs.watchFile()</code> watches a file.</li>
</ul>

<h1>ChangeLog</h1>

<p>According to <a href="https://github.com/joyent/node/blob/master/ChangeLog">ChangeLog</a>, I found that</p>

<ul>
<li><code>fs.watchFile()</code> is older API which is implemented on v0.1.18 as <code>process.watchFile()</code>.</li>
<li><code>fs.watch()</code> is newer API which is implemented on v0.5.9.</li>
</ul>

<h1>Source Code</h1>

<p>I cannot found official information any more, so I looked at source code for more understanding.</p>

<h2>fs.watch()</h2>

<p>Let&#39;s look at implementation of <code>fs.watch()</code>. (We use source code for <a href="https://github.com/joyent/node/tree/v0.10.19">v0.10.19</a>)</p>

<p>After I looked at <a href="https://github.com/joyent/node/blob/v0.10.19/lib/fs.js"><code>lib/fs.js</code></a> and <a href="https://github.com/joyent/node/blob/v0.10.19/src/fs_event_wrap.cc#L102"><code>src/fs_event_wrap.cc</code></a>, I found <code>fs.watch()</code> is implemented by <code>uv_fs_event_init()</code> function.</p>

<p>The functions whose name start with <code>uv</code> is defined by libuv. libuv is multi-platform support library for Node.js. It has features like asynchronous IO, thread pool, timer and so on.</p>

<p>So, look at <code>uv_fs_event_init()</code> function. I grepped under <code>deps/uv/src</code>. The results are as follows:</p>

<ul>
<li>unix\aix.c</li>
<li>unix\cygwin.c</li>
<li>unix\kqueue.c</li>
<li>unix\linux-inotify.c</li>
<li>unix\sunos.c</li>
<li>win\fs-event.c</li>
</ul>

<p>Each file has implementation for different platforms.</p>

<table><thead>
<tr>
<th>Platform</th>
<th>How to implement</th>
</tr>
</thead><tbody>
<tr>
<td>Linux</td>
<td>inotify</td>
</tr>
<tr>
<td>MacOS、*BSD</td>
<td>kqueue</td>
</tr>
<tr>
<td>Windows</td>
<td><code>ReadDirectoryChangesW()</code></td>
</tr>
<tr>
<td>Solaris</td>
<td>Event Ports</td>
</tr>
<tr>
<td>AIX</td>
<td>(Not supported)</td>
</tr>
<tr>
<td>Cygwin</td>
<td>(Not supported)</td>
</tr>
</tbody></table>

<p>Conclusion: <strong>fs.watch() uses native API</strong>.</p>

<h2>fs.watchFile()</h2>

<p>Let&#39;s look at <code>fs.watchFile()</code>.</p>

<p>After I looked at <a href="https://github.com/joyent/node/blob/v0.10.19/lib/fs.js"><code>lib/fs.js</code></a> and <a href="https://github.com/joyent/node/blob/v0.10.19/src/node_stat_watcher.cc#L112"><code>src/node_stat_watcher.cc</code></a>, I found <code>fs.watchFile()</code> is implemented by <code>uv_fs_poll_start()</code> function.</p>

<p>OK. Let&#39;s read <code>uv_fs_poll_start()</code> defined in <a href="https://github.com/joyent/node/blob/v0.10.19/deps/uv/src/fs-poll.c#L56"><code>deps/uv/src/fs-poll.c</code></a>.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">int uv_fs_poll_start(uv_fs_poll_t* handle,
                     uv_fs_poll_cb cb,
                     const char* path,
                     unsigned int interval) {
  // snip initialization

  if (uv_fs_stat(loop, &amp;ctx-&gt;fs_req, ctx-&gt;path, poll_cb))
    abort();
</code></pre></div>
<p>The point is <code>uv_fs_stat()</code>. This function executes  asynchronous <code>stat()</code>. The callback <code>poll_cb</code> is called when it completes.</p>

<p>Next, <a href="https://github.com/joyent/node/blob/v0.10.19/deps/uv/src/fs-poll.c#L139"><code>poll_cb()</code></a>.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">static void poll_cb(uv_fs_t* req) {
  // snip: trigger event, error handling, and so on

  /* Reschedule timer, subtract the delay from doing the stat(). */
  interval = ctx-&gt;interval;
  interval -= (uv_now(ctx-&gt;loop) - ctx-&gt;start_time) % interval;

  if (uv_timer_start(&amp;ctx-&gt;timer_handle, timer_cb, interval, 0))
    abort();
}
</code></pre></div>
<p>First it analyzes the stat result, and then it starts next timer so that <code>timer_cb()</code> will be called <code>interval</code> later.</p>

<p><code>timer_cb()</code> calls <code>uv_fs_stat()</code> again. I got it! <code>fs.stat()</code> is called periodically.</p>

<p>Conclusion: <strong>fs.watchFile() periodically executes fs.stat()</strong>.</p>

<h1>Conclusion</h1>

<p><code>fs.watch()</code>:</p>

<ul>
<li>is newer API and recommended.</li>
<li>uses native watching functions supported by OS, so doesn&#39;t waste CPU on waiting.</li>
<li>doesn&#39;t support all platforms such as AIX and Cygwin.</li>
</ul>

<p><code>fs.watchFile()</code>:</p>

<ul>
<li>is old API and not recommended.</li>
<li>calls stat periodically, so uses CPU even when nothing changes.</li>
<li>runs on any platforms.</li>
</ul>
]]></description>
		</item>

		<item>
			<title>Use symlinks in git difftool --dir-diff on Windows</title>
			<link>http://tech.nitoyon.com/en/blog/2013/07/09/symlink-dir-diff-on-windows/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/07/09/symlink-dir-diff-on-windows/</guid>
			<pubDate>Tue, 09 Jul 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>I like <code>git difftool --dir-diff</code> because it checks out the modified files to a temporary directory and executes diff tool with directory pathes.</p>

<p>On Unix and MacOS, <code>git difftool --dir-diff</code> create a symbolic link to the working directory if a right-hand file has the same SHA1 as the file in the working directory.  It&#39;s very useful when we modify right-hand files with a difftool.</p>

<p>On Windows, instead of creating symbolic links, <code>git difftool --dir-diff</code> copy back right-hand files to working directory after difftool program exits.  I want to use symlinks on Git for Windows like Unix and MacOS.</p>

<h1>Quick Hack Patch</h1>

<p>Environment: Git for Windows 1.8.3 and Windows 7 (64bit).</p>

<p>Patch for <code>C:\Program Files (x86)\Git\libexec\git-core\git-difftool</code>.</p>
<div class="highlight"><pre><code class="diff language-diff" data-lang="diff">--- git-difftool    Sun Jun  2 11:28:06 2013
+++ git-difftool    Tue Jul  9 00:42:02 2013
@@ -283,7 +283,7 @@
            exit_cleanup($tmpdir, 1);
        }
        if ($symlinks) {
-           symlink(&quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
+           !system(&quot;git&quot;, &quot;mklink&quot;, &quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
            exit_cleanup($tmpdir, 1);
        } else {
            copy(&quot;$workdir/$file&quot;, &quot;$rdir/$file&quot;) or
@@ -448,7 +448,7 @@
    my $indices_loaded = 0;

    for my $file (@worktree) {
-       next if $symlinks &amp;&amp; -l &quot;$b/$file&quot;;
+       next if $symlinks;
        next if ! -f &quot;$b/$file&quot;;

        if (!$indices_loaded) {
</code></pre></div>
<p>Save this patch to somewhere, and run GitBash as administrator.</p>
<div class="highlight"><pre><code class="console language-console" data-lang="console">$ cd /c/Program\ Files\ \(x86\)/Git/libexec/git-core/
$ patch &lt; ~/git-difftool.patch
patching file `git-difftool&#39;
</code></pre></div>
<p>Create a file on <code>C:\Program Files (x86)\Git\libexec\git-core\git-mklink</code>:</p>
<div class="highlight"><pre><code class="sh language-sh" data-lang="sh">#!/bin/sh

cmd.exe /c &quot;mklink \&quot;$2\&quot; \&quot;$1\&quot;&quot; &gt; /dev/null
</code></pre></div>
<p>(This script is necessary for converting <code>/tmp/</code> directory to Windows path)</p>

<h1>How to Use</h1>

<p>First, configure difftool on <code>.gitconfig</code>. For example, set <a href="http://winmerge.org/">WinMerge</a> as difftool.</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[diff]
    tool = winmerge
[difftool winmerge]
    path = C:/Program Files (x86)/WinMerge/winmergeu.exe
    cmd = \&quot;C:/Program Files (x86)/WinMerge/winmergeu.exe\&quot; -r -u \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;
</code></pre></div>
<p>Run GitBash as an administrator, and enter following command.</p>
<div class="highlight"><pre><code class="console language-console" data-lang="console">$ git difftool -d --symlinks [&lt;commit&gt; [&lt;commit&gt;]]
</code></pre></div>
<p>(On Windows, administrator privileges is required to create symbolic links)</p>

<p>If you want, create an alias on <code>.gitconfig</code>.</p>
<div class="highlight"><pre><code class="ini language-ini" data-lang="ini">[alias]
    d = difftool -d --symlinks
</code></pre></div>
<p>Enjoy.</p>
]]></description>
		</item>

		<item>
			<title>Jekyll: Use Grunt instead of --watch option</title>
			<link>http://tech.nitoyon.com/en/blog/2013/06/25/jekyll-grunt/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/06/25/jekyll-grunt/</guid>
			<pubDate>Tue, 25 Jun 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>I&#39;m using <a href="https://github.com/mojombo/jekyll">Jekyll</a> for building my site.  When I write a new entry, I have executed <code>jekyll --auto</code>. But I noticed that ruby consumes up to 25% of CPU on my quad core PC.</p>

<p>This problem is caused by <code>directory_watcher</code> module. It executes <code>File::Stat()</code> on all files under the given directory every one second! It works fine when the number of files is small, but as it grow up, it begins wasting our CPU.</p>

<p>For example, my site has over 600+ posts by which Jekyll generates 900 files. And more, there are 5000 files under <code>.git</code> dir. Suprisingly, Jekyll ~0.12 watches all files under the current directory, which means that it execute stat to these 6,500 files every one second.</p>

<p>Jekyll 1.0&#39;s <code>jekyll build --watch</code> doesn&#39;t watch <code>.git</code> and <code>_site</code> directory. Despite of such improvement, ruby still uses up to 10% of CPU.</p>

<p>So I decided to use <a href="http://gruntjs.com/">Grunt</a> instead of using <code>--watch</code> (or <code>--auto</code>) option.</p>

<h1>Grunt config files</h1>

<p>I&#39;m use following versions:</p>

<ul>
<li>Jekyll 1.0.3</li>
<li>Grunt 0.4.1

<ul>
<li><code>grunt-shell-spawn</code> plugin</li>
<li><code>grunt-contrib-watch</code> plugin</li>
</ul></li>
</ul>

<p>At first, I used <code>grunt-jekyll</code> instead of <code>grunt-shell-spawn</code>, but <code>grunt-jekyll</code> plugin doesn&#39;t show Jekyll&#39;s output until it exits.</p>

<p>See <a href="http://gruntjs.com/getting-started">Getting started - Grunt</a> to setup Grunt.</p>

<p>Here is my <code>package.json</code> and <code>Gruntfile.js</code>.</p>

<h2>package.json</h2>
<div class="highlight"><pre><code class="json language-json" data-lang="json">{
  &quot;name&quot;: &quot;tech-ni&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.1&quot;,
    &quot;grunt-shell-spawn&quot;: &quot;~0.2.4&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.4.4&quot;
  }
}
</code></pre></div>
<h2>Gruntfile.js</h2>
<div class="highlight"><pre><code class="js language-js" data-lang="js">module.exports = function(grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    shell: {
      jekyll: {
        command: &#39;jekyll build&#39;,
        options: {
          async: false
        }
      }
    },
    watch: {
      jekyll: {
        files: [&#39;_posts/**/*.md&#39;, &#39;_layout/*.html&#39;, &#39;_includes/*.html&#39;],
        tasks: [&#39;shell:jekyll&#39;]
      }
    }
  });

  grunt.loadNpmTasks(&#39;grunt-shell-spawn&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);

  grunt.registerTask(&#39;default&#39;, [&#39;shell:jekyll&#39;]);
};
</code></pre></div>
<p>(If you&#39;re using Jekyll ~0.12, replace <code>jekyll build</code> to <code>jekyll</code>)</p>

<h1>How to Use</h1>

<p>By entering <code>grunt watch</code>, it starts watching files. When some posts or HTML files are modified, grunt executes <code>jekyll build</code>.</p>

<p>But CPU usage is not 0%. It turns out that <code>grunt-contrib-watch</code> doesn&#39;t use native watch API -- <code>fs.watch()</code>. It uses <code>gaze</code> module which execute <code>fs.statSync()</code> periodically.</p>

<p>Oh!! Nothing changes...</p>

<p>It seems that <code>fs.watch()</code> had many problems such as not reporting filenames on mac and executing <code>fs.stat()</code> became popular. Oh, hell!</p>
]]></description>
		</item>

		<item>
			<title>Bugzilla: Edit bug status using Perl script</title>
			<link>http://tech.nitoyon.com/en/blog/2013/05/17/bugzilla-hack/</link>
			<guid>http://tech.nitoyon.com/en/blog/2013/05/17/bugzilla-hack/</guid>
			<pubDate>Fri, 17 May 2013 00:00:00 +0900</pubDate>
			<description><![CDATA[<p>I wrote a perl script which adds a comment and modify status of bug in Bugzilla. This script is useful if you want to fix a bug automatically with a commit log.</p>
<div class="highlight"><pre><code class="perl language-perl" data-lang="perl">#!/usr/bin/perl -I/path/to/bugzilla -I/path/to/bugzilla/lib

use strict;
use Bugzilla;
use Bugzilla::User;
use Bugzilla::Status;
use Bugzilla::Bug;
use utf8;

&amp;update_bug(1, &quot;ほげほげ&quot;);

# API document: http://www.bugzilla.org/docs/4.2/en/html/api/
sub update_bug {
    my ($bug_id, $text) = @_;

    # open bug
    my $bug = Bugzilla::Bug-&gt;new($bug_id);
    die $bug-&gt;error if defined $bug-&gt;error;

    # get user
    my $user = Bugzilla::User-&gt;new({name =&gt; &#39;admin@example.com&#39;});
    die &#39;user not found!!!!&#39; unless defined $user;

    # login
    Bugzilla-&gt;set_user($user);

    # comment to the bug
    $bug-&gt;add_comment($text);

    # FIXED
    $bug-&gt;set_bug_status(Bugzilla::Status-&gt;new({name =&gt; &#39;RESOLVED&#39;}),
                         {resolution =&gt; &#39;FIXED&#39;});

    # save to database
    $bug-&gt;update();
}
</code></pre></div>
<p>Tested on Bugzilla 4.2.5.</p>

<p>When you are using Git, call this subroutine from <code>post-receive</code> hook.</p>

<p>Warnings:</p>

<ul>
<li>This script must be executed on the server Bugzilla installed.</li>
<li>I&#39;m using undocumented module, <code>Bugzilla::Bug</code>. At first, I tried to use <code>Bugzilla::WebService::Bug</code> (documented), but it depends on <code>Test/Taint</code> module and my server doesn&#39;t have the module.</li>
</ul>
]]></description>
		</item>

	</channel>
</rss>